<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PolyMind Cognitive Assessment</title>
<style>
    body {
        font-family: "Inter", system-ui;
        background: white;
        color: black;
        margin: 0;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .screen {
        display: none;
        width: 100%;
        height: 100%;
        max-width: 1200px;
        padding: 40px;
        box-sizing: border-box;
    }
    .active { display: block; }

    button {
        padding: 14px 32px;
        font-size: 18px;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        background: black;
        color: white;
        font-weight: 600;
        margin-top: 16px;
    }
    button:hover { opacity: 0.85; }

    .question {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 70px;
        margin-top: 25px;
    }
    .panel {
        background: white;
        padding: 30px;
        border-radius: 20px;
        border: 2px solid #ddd;
    }

    .options {
        display: grid;
        grid-template-columns: repeat(2, 160px);
        gap: 25px;
        margin-top: 15px;
    }

    svg.option {
        background: white;
        border: 3px solid transparent;
        border-radius: 12px;
        transition: 0.15s;
    }
    svg.option:hover { transform: scale(1.06); }
    .selected { border-color: black !important; }

    .resultShapes {
        display:flex;
        justify-content:center;
        align-items:center;
        gap:60px;
        margin-top:20px;
    }

    /* Level 2 */
    #level2Container svg {
        border: 1px solid #ddd;
        border-radius: 8px;
        background: #fafafa;
    }
</style>
</head>

<body>

<!-- INTRO -->
<div id="intro" class="screen active">
    <div style="text-align:center; margin-top:10%">
        <h1 style="font-size:60px;">PolyMind</h1>
        <h3>Spatial Cognitive Assessment</h3>
        <button onclick="showScreen('instructions')">Begin</button>
    </div>
</div>

<!-- INSTRUCTIONS LEVEL 1 -->
<div id="instructions" class="screen">
    <div style="text-align:center; margin-top:10%">
        <h2>Level 1 Instructions</h2>
        <p>
            Match the polygon on the left to the identical polygon on the right.<br>
            It may be flipped or rotated. Select the correct shape and submit.
        </p>
        <button onclick="startLevel1()">Start Level 1</button>
    </div>
</div>

<!-- LEVEL 1 -->
<div id="level1" class="screen">
    <div style="text-align:center;">
        <h2>Level 1</h2>
        <p id="levelText">Task: Choose the flipped shape</p>
    </div>
    <div id="questionContainer"></div>
    <div style="text-align:center;">
        <button onclick="submitAnswer()">Submit</button>
    </div>
</div>

<!-- RESULTS LEVEL 1 -->
<div id="results" class="screen">
    <div style="text-align:center; margin-top:5%">
        <h2>Level 1 Results</h2>
        <div id="summary" style="font-size:20px;"></div>
        <button onclick="showScreen('level2Intro')">Go to Level 2</button>
    </div>
</div>

<!-- LEVEL 2 INTRO -->
<div id="level2Intro" class="screen">
    <div style="text-align:center; margin-top:10%">
        <h2>Level 2 Instructions</h2>
        <p>
            You will briefly see a polygon (up to 7 vertices) for 5 seconds.<br>
            Then it will disappear and you will see only the labeled points (1, 2, 3, ...).<br>
            Your task is to reconstruct the polygon by connecting the points in the correct order.<br><br>
            Draw an edge by pressing on one vertex and releasing on another vertex.<br>
            Click on an existing edge to erase it.<br>
            You can take up to 3 hints. Each hint reveals one correct edge, with a 15 second gap between hints.
        </p>
        <button onclick="startLevel2()">Start Level 2</button>
    </div>
</div>

<!-- LEVEL 2 -->
<div id="level2" class="screen">
    <div style="text-align:center;">
        <h2>Level 2</h2>
        <p id="level2Text">Memorize the polygon.</p>
    </div>
    <div id="level2Container" style="display:flex; justify-content:center; margin-top:20px;"></div>
    <div style="text-align:center; margin-top:20px;">
        <button id="hintBtn" onclick="useHint()" disabled>Hint</button>
        <button id="submitL2Btn" onclick="submitLevel2()" disabled>Submit</button>
        <div id="hintInfo" style="margin-top:10px; font-size:14px; color:#555;"></div>
    </div>
</div>

<!-- RESULTS LEVEL 2 -->
<div id="results2" class="screen">
    <div style="text-align:center; margin-top:5%">
        <h2>Level 2 Results</h2>
        <div id="summary2" style="font-size:20px; text-align:left; max-width:800px; margin:0 auto;"></div>
        <div style="text-align:center;">
            <button onclick="alert('Further levels coming soon!')">Finish</button>
        </div>
    </div>
</div>

<script>
// =============== SHARED UTILS ===============
function showScreen(id){
  document.querySelectorAll(".screen").forEach(s=>s.classList.remove("active"));
  document.getElementById(id).classList.add("active");
}

function shuffle(arr){
  return arr
    .map(v => ({ v, sort: Math.random() }))
    .sort((a,b)=>a.sort-b.sort)
    .map(({v})=>v);
}

// =============== LEVEL 1 DATA ===============
const flipProblems = [
  {target:`<polygon points="50,10 85,40 70,90 30,90 15,40"/>`,
   correct:`<g transform="scale(-1,1) translate(-100,0)"><polygon points="50,10 85,40 70,90 30,90 15,40"/></g>`},
  {target:`<polygon points="40,10 80,40 70,85 25,85 15,40"/>`,
   correct:`<g transform="scale(-1,1) translate(-100,0)"><polygon points="40,10 80,40 70,85 25,85 15,40"/></g>`},
  {target:`<polygon points="30,15 70,15 85,45 50,85 15,45"/>`,
   correct:`<g transform="scale(-1,1) translate(-100,0)"><polygon points="30,15 70,15 85,45 50,85 15,45"/></g>`}
];

const rotationProblems = [
  {target:`<polygon points="50,10 85,35 70,80 30,80 15,35"/>`,
   correct:`<g transform="rotate(90 50 50)"><polygon points="50,10 85,35 70,80 30,80 15,35"/></g>`},
  {target:`<polygon points="40,10 90,60 50,90 10,60"/>`,
   correct:`<g transform="rotate(60 50 50)"><polygon points="40,10 90,60 50,90 10,60"/></g>`}
];

const distractors = [
  `<polygon points="20,20 80,20 80,80 20,80"/>`,
  `<polygon points="50,15 85,75 15,75"/>`,
  `<polygon points="15,60 80,30 60,90"/>`
];

// =============== LEVEL 1 STATE ===============
let stage="flip";
let selectedElement=null;
let flipStart, flipEnd, rotationStart, rotationEnd;
let flipCorrect, rotationCorrect;
let flipCorrectSvg, rotationCorrectSvg;
let flipMistake=null, rotationMistake=null;

// =============== LEVEL 1 LOGIC ===============
function startLevel1(){
  stage="flip";
  selectedElement=null;
  flipMistake=null;
  rotationMistake=null;
  flipStart = performance.now();
  document.getElementById("levelText").innerText="Task: Choose the flipped shape";
  showScreen("level1");
  loadQuestion();
}

function loadQuestion(){
  selectedElement=null;
  const problem = (stage==="flip"
      ? flipProblems[Math.floor(Math.random()*flipProblems.length)]
      : rotationProblems[Math.floor(Math.random()*rotationProblems.length)]);

  if(stage==="flip") flipCorrectSvg = problem.correct;
  else rotationCorrectSvg = problem.correct;

  const choices = shuffle([
    {svg: problem.correct, correct:true},
    ...shuffle(distractors).slice(0,3).map(d=>({svg:d, correct:false}))
  ]);

  document.getElementById("questionContainer").innerHTML = `
  <div class="question">
    <div class="panel">
      <svg width="260" height="260" viewBox="0 0 100 100" stroke="black" fill="none" stroke-width="3">
        ${problem.target}
      </svg>
    </div>
    <div class="panel">
      <div class="options">
        ${choices.map(c => `
          <svg class="option" data-correct="${c.correct}"
               onclick="selectOption(this)" width="160" height="160" viewBox="0 0 100 100" stroke="black" fill="none" stroke-width="3">
            ${c.svg}
          </svg>
        `).join("")}
      </div>
    </div>
  </div>`;
}

function selectOption(el){
  document.querySelectorAll(".option").forEach(s=>s.classList.remove("selected"));
  selectedElement = el;
  el.classList.add("selected");
}

function submitAnswer(){
  if(!selectedElement) return;

  const correct = selectedElement.dataset.correct==="true";

  if(stage==="flip"){
    flipEnd=performance.now();
    flipCorrect=correct;
    if(!correct) flipMistake=selectedElement.outerHTML;
    stage="rotation";
    rotationStart = performance.now();
    document.getElementById("levelText").innerText="Task: Choose the rotated shape";
    loadQuestion();
  }else{
    rotationEnd=performance.now();
    rotationCorrect=correct;
    if(!correct) rotationMistake=selectedElement.outerHTML;
    endLevel1();
  }
}

function endLevel1(){
  const flipTime=((flipEnd-flipStart)/1000).toFixed(2);
  const rotationTime=((rotationEnd-rotationStart)/1000).toFixed(2);

  const flipStatus = flipCorrect ? "Correct" : "Wrong";
  const rotationStatus = rotationCorrect ? "Correct" : "Wrong";

  const flipMistakeHtml = flipMistake ? `
    <div class="resultShapes">
      <div>
        Original:<br>
        <svg viewBox="0 0 100 100" width="160" height="160" stroke="black" fill="none" stroke-width="3">${flipCorrectSvg}</svg>
      </div>
      <div>
        Mistake:<br>
        <svg viewBox="0 0 100 100" width="160" height="160" stroke="black" fill="none" stroke-width="3">${extractInner(flipMistake)}</svg>
      </div>
    </div><br>
  ` : "No mistake<br><br>";

  const rotationMistakeHtml = rotationMistake ? `
    <div class="resultShapes">
      <div>
        Original:<br>
        <svg viewBox="0 0 100 100" width="160" height="160" stroke="black" fill="none" stroke-width="3">${rotationCorrectSvg}</svg>
      </div>
      <div>
        Mistake:<br>
        <svg viewBox="0 0 100 100" width="160" height="160" stroke="black" fill="none" stroke-width="3">${extractInner(rotationMistake)}</svg>
      </div>
    </div>
  ` : "No mistake";

  document.getElementById("summary").innerHTML = `
    <strong>Round 1 — Flip</strong><br>
    Result: ${flipStatus}<br>
    Time: ${flipTime} sec<br>
    ${flipMistakeHtml}
    <strong>Round 2 — Rotation</strong><br>
    Result: ${rotationStatus}<br>
    Time: ${rotationTime} sec<br>
    ${rotationMistakeHtml}
  `;
  showScreen("results");
}

function extractInner(full){
  return full.replace(/<svg[^>]*>/,"").replace("</svg>","");
}

// =============== LEVEL 2 DATA ===============
// Two polygons, up to 7 vertices, in [0,100] coordinate space
const level2Polygons = [
  {
    vertices: [
      {x:20,y:20},
      {x:80,y:20},
      {x:90,y:50},
      {x:70,y:85},
      {x:30,y:85},
      {x:10,y:50}
    ]
  },
  {
    vertices: [
      {x:25,y:15},
      {x:75,y:15},
      {x:90,y:45},
      {x:70,y:80},
      {x:40,y:90},
      {x:15,y:60},
      {x:15,y:35}
    ]
  }
];

// =============== LEVEL 2 STATE ===============
let l2RoundIndex = 0;
let l2Results = [];
let l2CurrentEdges = [];    // {i,j,viaHint}
let l2HintsUsed = 0;
let l2LastHintTime = 0;
let l2ErasedEdges = 0;
let l2DragStartIndex = null;
let l2RoundStartTime = 0;   // start of reconstruction
let l2ViewingTimeoutId = null;

// =============== LEVEL 2 LOGIC ===============
function startLevel2(){
  l2RoundIndex = 0;
  l2Results = [];
  showScreen("level2");
  startLevel2Round();
}

function startLevel2Round(){
  const poly = level2Polygons[l2RoundIndex];
  const vertices = poly.vertices;

  // Reset state for this round
  l2CurrentEdges = [];
  l2HintsUsed = 0;
  l2LastHintTime = 0;
  l2ErasedEdges = 0;
  l2DragStartIndex = null;

  const hintBtn = document.getElementById("hintBtn");
  const submitBtn = document.getElementById("submitL2Btn");
  const hintInfo = document.getElementById("hintInfo");
  hintBtn.disabled = true;
  submitBtn.disabled = true;
  hintInfo.textContent = "Memorize the polygon (5 seconds).";
  document.getElementById("level2Text").textContent = "Memorize the polygon.";

  // Show original polygon
  document.getElementById("level2Container").innerHTML = `
    <svg id="level2Svg" viewBox="0 0 100 100" width="400" height="400">
      <polygon points="${vertices.map(v=>`${v.x},${v.y}`).join(" ")}"
               fill="none" stroke="black" stroke-width="2"/>
    </svg>
  `;

  // After 5 seconds, switch to reconstruction view
  if(l2ViewingTimeoutId) clearTimeout(l2ViewingTimeoutId);
  l2ViewingTimeoutId = setTimeout(()=> {
    startReconstruction(vertices);
  }, 5000);
}

function startReconstruction(vertices){
  document.getElementById("level2Text").textContent = "Reconstruct the polygon by connecting the labeled points.";
  const hintBtn = document.getElementById("hintBtn");
  const submitBtn = document.getElementById("submitL2Btn");
  const hintInfo = document.getElementById("hintInfo");
  hintBtn.disabled = false;
  submitBtn.disabled = false;
  hintInfo.textContent = "You can use up to 3 hints (15s gap between hints).";

  l2RoundStartTime = performance.now();
  renderLevel2Svg(vertices);
}

function renderLevel2Svg(vertices){
  const container = document.getElementById("level2Container");
  // Build edges (lines), then vertices + labels
  const linesHtml = l2CurrentEdges.map((e,idx)=>{
    const a = vertices[e.i];
    const b = vertices[e.j];
    return `<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}"
                  stroke="black" stroke-width="2"
                  data-index="${idx}" />`;
  }).join("");

  const pointsHtml = vertices.map((v,idx)=>`
    <g>
      <circle cx="${v.x}" cy="${v.y}" r="3.5" fill="black" data-vertex="${idx}"></circle>
      <text x="${v.x+3}" y="${v.y-3}" font-size="5" fill="black">${idx+1}</text>
    </g>
  `).join("");

  container.innerHTML = `
    <svg id="level2Svg" viewBox="0 0 100 100" width="400" height="400">
      ${linesHtml}
      ${pointsHtml}
    </svg>
  `;

  const svg = document.getElementById("level2Svg");

  // Edge erase handlers
  svg.querySelectorAll("line").forEach(line=>{
    line.addEventListener("click", ()=>{
      const index = parseInt(line.getAttribute("data-index"),10);
      if(!isNaN(index)){
        l2CurrentEdges.splice(index,1);
        l2ErasedEdges += 1;
        renderLevel2Svg(vertices);
      }
    });
  });

  // Vertex drag handlers
  svg.querySelectorAll("circle").forEach(circle=>{
    const idx = parseInt(circle.getAttribute("data-vertex"),10);
    circle.addEventListener("mousedown", ()=>{
      l2DragStartIndex = idx;
    });
    circle.addEventListener("mouseup", ()=>{
      if(l2DragStartIndex !== null && l2DragStartIndex !== idx){
        addL2Edge(l2DragStartIndex, idx, false, vertices);
      }
      l2DragStartIndex = null;
    });
  });
}

function addL2Edge(i,j,viaHint, vertices){
  if(i>j){ const t=i; i=j; j=t; }
  // check duplicate
  if(l2CurrentEdges.some(e=>e.i===i && e.j===j)) return;
  l2CurrentEdges.push({i,j,viaHint});
  renderLevel2Svg(vertices);
}

function useHint(){
  const now = Date.now();
  const hintBtn = document.getElementById("hintBtn");
  const hintInfo = document.getElementById("hintInfo");
  const poly = level2Polygons[l2RoundIndex];
  const vertices = poly.vertices;
  const n = vertices.length;

  if(l2HintsUsed >= 3){
    hintInfo.textContent = "Maximum of 3 hints used.";
    return;
  }
  if(l2LastHintTime && now - l2LastHintTime < 15000){
    const remaining = Math.ceil((15000 - (now - l2LastHintTime))/1000);
    hintInfo.textContent = `Next hint available in ${remaining} seconds.`;
    return;
  }

  // true edges: (0-1,1-2,...,n-1-0)
  const trueEdges = [];
  for(let k=0;k<n;k++){
    const a = k;
    const b = (k+1)%n;
    const ii = Math.min(a,b);
    const jj = Math.max(a,b);
    trueEdges.push({i:ii,j:jj});
  }
  // find one missing edge
  let chosen = null;
  for(const e of trueEdges){
    if(!l2CurrentEdges.some(x=>x.i===e.i && x.j===e.j)){
      chosen = e;
      break;
    }
  }
  if(!chosen){
    hintInfo.textContent = "All edges already revealed.";
    return;
  }

  l2HintsUsed += 1;
  l2LastHintTime = now;
  addL2Edge(chosen.i, chosen.j, true, vertices);
  hintInfo.textContent = `Hint used: ${l2HintsUsed}/3`;
}

function submitLevel2(){
  const poly = level2Polygons[l2RoundIndex];
  const vertices = poly.vertices;
  const n = vertices.length;
  const roundEnd = performance.now();
  const timeTaken = ((roundEnd - l2RoundStartTime)/1000).toFixed(2);

  // true edges
  const trueEdges = [];
  for(let k=0;k<n;k++){
    const a = k;
    const b = (k+1)%n;
    const ii = Math.min(a,b);
    const jj = Math.max(a,b);
    trueEdges.push(`${ii}-${jj}`);
  }
  const userEdges = l2CurrentEdges.map(e=>{
    const ii = Math.min(e.i,e.j);
    const jj = Math.max(e.i,e.j);
    return `${ii}-${jj}`;
  });

  const trueSet = new Set(trueEdges);
  const userSet = new Set(userEdges);

  let missing = 0;
  for(const te of trueEdges){
    if(!userSet.has(te)) missing++;
  }
  let wrong = 0;
  for(const ue of userEdges){
    if(!trueSet.has(ue)) wrong++;
  }

  // intersections
  let intersect = false;
  for(let i=0;i<l2CurrentEdges.length;i++){
    for(let j=i+1;j<l2CurrentEdges.length;j++){
      if(edgesIntersect(l2CurrentEdges[i], l2CurrentEdges[j], vertices)){
        intersect = true;
        break;
      }
    }
    if(intersect) break;
  }

  // follow order of labels? (only adjacent edges allowed)
  let followOrder = true;
  for(const e of l2CurrentEdges){
    const a = e.i;
    const b = e.j;
    const diff = Math.abs(a-b);
    if(!(diff === 1 || diff === n-1)){
      followOrder = false;
      break;
    }
  }

  const correct = (missing===0 && wrong===0 && !intersect);

  l2Results.push({
    correct,
    time: timeTaken,
    hints: l2HintsUsed,
    missingEdges: missing,
    wrongEdges: wrong,
    intersect,
    erased: l2ErasedEdges,
    followOrder
  });

  // next round or results
  if(l2RoundIndex === level2Polygons.length - 1){
    endLevel2();
  }else{
    l2RoundIndex++;
    startLevel2Round();
  }
}

function edgesIntersect(e1, e2, vertices){
  const a=e1.i, b=e1.j, c=e2.i, d=e2.j;
  // share endpoint => ignore
  if(a===c || a===d || b===c || b===d) return false;

  const p1 = vertices[a];
  const p2 = vertices[b];
  const p3 = vertices[c];
  const p4 = vertices[d];

  return segmentsIntersect(p1,p2,p3,p4);
}

function segmentsIntersect(p1,p2,p3,p4){
  function orient(p,q,r){
    const val = (q.y-p.y)*(r.x-q.x) - (q.x-p.x)*(r.y-q.y);
    if(val===0) return 0;
    return val>0 ? 1 : 2;
  }
  const o1 = orient(p1,p2,p3);
  const o2 = orient(p1,p2,p4);
  const o3 = orient(p3,p4,p1);
  const o4 = orient(p3,p4,p2);
  if(o1!==o2 && o3!==o4) return true;
  return false;
}

function endLevel2(){
  let html = "";
  l2Results.forEach((r,idx)=>{
    html += `<strong>Round ${idx+1}</strong><br>`;
    html += `Result: ${r.correct ? "Correct" : "Wrong"}<br>`;
    html += `Time taken: ${r.time} sec<br>`;
    html += `Hints used: ${r.hints}<br>`;
    html += `Edges missing: ${r.missingEdges}<br>`;
    html += `Edges wrong: ${r.wrongEdges}<br>`;
    html += `Any intersections: ${r.intersect ? "Yes" : "No"}<br>`;
    html += `Edges erased: ${r.erased}<br>`;
    html += `Followed label order: ${r.followOrder ? "Yes" : "No"}<br><br>`;
  });
  document.getElementById("summary2").innerHTML = html;
  showScreen("results2");
}
</script>

</body>
</html>
