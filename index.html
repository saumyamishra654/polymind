<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>PolyMind Cognitive Assessment</title>
<style>
    * {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    body {
        font-family: "Inter", system-ui;
        background: white;
        color: black;
        margin: 0;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .screen {
        display: none;
        width: 100%;
        height: 100%;
        max-width: 1200px;
        padding: 40px;
        box-sizing: border-box;
    }
    .active { display: block; }

    button {
        padding: 14px 32px;
        font-size: 18px;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        background: black;
        color: white;
        font-weight: 600;
        margin-top: 16px;
    }
    button:hover { opacity: 0.85; }

    .question {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 70px;
        margin-top: 25px;
    }

    .panel {
        background: white;
        padding: 30px;
        border-radius: 20px;
        border: 2px solid #ddd;
    }

    .options {
        display: grid;
        grid-template-columns: repeat(2, 160px);
        gap: 25px;
        margin-top: 15px;
    }

    svg.option {
        background: white;
        border: 3px solid transparent;
        border-radius: 12px;
        transition: 0.15s;
    }
    svg.option:hover { transform: scale(1.06); }
    .selected { border-color: black !important; }

    .resultShapes {
        display:flex;
        justify-content:center;
        align-items:center;
        gap:60px;
        margin-top:20px;
    }

    svg text {
        pointer-events: none; /* labels not clickable/selectable */
    }

    #level2Container svg,
    #level3Container svg,
    #level4Container svg,
    #level5Container svg {
        border: 1px solid #ddd;
        border-radius: 8px;
        background: #fafafa;
    }

    .results-table {
        border-collapse: collapse;
        margin: 10px auto 30px;
        width: 80%;
        font-size: 16px;
    }
    .results-table td {
        border-bottom: 1px solid #ccc;
        padding: 8px 10px;
    }
    .results-table td:first-child {
        font-weight: 700;
        width: 45%;
    }

    /* Instructions layout */
    .centered-container {
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
    }



.logo-slot {
    width: 200px;      /* controls displayed logo size */
    height: 100px;
    margin-bottom: 24px;

    display: flex;
    align-items: center;
    justify-content: center;
}

.logo-slot img {
    max-width: 150%;   /* KEEP logo inside the slot */
    max-height: 150%;
    object-fit: contain; 
    display: block;
}



    .instructions-container {
        max-width: 800px;
        margin: 0 auto;
        text-align: left;
    }

    .instructions-container h2 {
        text-align: center;
        margin-bottom: 16px;
    }

    .instructions-section {
        margin-bottom: 18px;
    }

    .instructions-section h3 {
        margin: 8px 0;
        font-size: 18px;
    }

    .instructions-section ul {
        margin: 4px 0 4px 20px;
        padding: 0;
    }

    .instructions-section li {
        margin-bottom: 4px;
        line-height: 1.4;
    }
</style>
</head>

<body>

<!-- MODE SELECTION -->
<div id="modeSelection" class="screen active">
    <div class="centered-container">
        <h1 style="font-size:60px; margin:0;">PolyMind</h1>
        <h3 style="margin-top:8px;">Select Mode</h3>
        <div style="margin-top:30px;">
            <button onclick="setMode('dev')" style="margin:10px;">Developer Mode</button>
            <button onclick="setMode('physician')" style="margin:10px;">Physician Mode</button>
            <button onclick="setMode('patient')" style="margin:10px;">Patient Mode</button>
        </div>
        <div style="margin-top:30px; max-width:600px; font-size:14px; text-align:left;">
            <p><strong>Developer Mode:</strong> Jump to any level for testing.</p>
            <p><strong>Physician Mode:</strong> Full assessment with result screens shown after each level.</p>
            <p><strong>Patient Mode:</strong> Full assessment without result screens, download CSV at the end.</p>
        </div>
    </div>
</div>

<!-- INTRO (opening page, centered, with logo space) -->
<div id="intro" class="screen">
    <div class="centered-container">
<div class="logo-slot">
    <img src="polymind.png" alt="Logo">
</div>
        <h1 style="font-size:60px; margin:0;">PolyMind</h1>
        <h3 style="margin-top:8px;">Geometry Based Cognitive Assessment</h3>
        <p style="margin-top:18px; max-width:600px;">
            This assessment measures how you perceive, remember, and reconstruct shapes.
        </p>
        <button onclick="showScreen('instructions')">View Instructions</button>
    </div>
</div>

<!-- DEV MODE LEVEL SELECTION -->
<div id="devLevelSelection" class="screen">
    <div class="centered-container">
        <h2>Developer Mode - Select Level</h2>
        <div style="margin-top:30px;">
            <button onclick="startLevel1()" style="margin:10px;">Level 1: Mental Rotation</button><br>
            <button onclick="showScreen('level2Intro')" style="margin:10px;">Level 2: Labeled Reconstruction</button><br>
            <button onclick="showScreen('level3Intro')" style="margin:10px;">Level 3: Unlabeled Reconstruction</button><br>
            <button onclick="showScreen('level4Intro')" style="margin:10px;">Level 4: Nested Shapes</button><br>
            <button onclick="showScreen('level5Intro')" style="margin:10px;">Level 5: Multi-Shape</button>
        </div>
        <div style="margin-top:30px;">
            <button onclick="showScreen('modeSelection')">Back to Mode Selection</button>
        </div>
    </div>
</div>

<!-- GLOBAL INSTRUCTIONS — SCREEN 1 -->
<div id="instructions" class="screen">
    <div class="centered-container">
        <div class="instructions-container">
            
            <h2>Welcome to PolyMind</h2>
            <p>This assessment measures your spatial reasoning and geometric reconstruction skills through a series of interactive levels.</p>

            <h3>What to Expect</h3>
            <ul>
                <li>The test progresses through multiple levels of increasing complexity.</li>
                <li>Each level involves recognizing, reconstructing, or generating shapes.</li>
                <li>You will receive feedback after each level before moving forward.</li>
            </ul>

            <div style="text-align:center; margin-top:18px;">
                <button onclick="showScreen('instructions2')">Next</button>
            </div>

        </div>
    </div>
</div>

<!-- GLOBAL INSTRUCTIONS — SCREEN 2 -->
<div id="instructions2" class="screen">
    <div class="centered-container">
        <div class="instructions-container">

            <h2>Drawing Shapes</h2>

            <h3>Drawing Edges</h3>
            <ul>
                <li>Shapes are built by connecting the points shown on the screen.</li>
                <li><strong>To draw an edge:</strong> click and hold on one point, drag to another point, and release.</li>
                <li>Each connected pair becomes an edge of your reconstructed shape.</li>
            </ul>

            <h3>Erasing Edges</h3>
            <ul>
                <li>Click directly on an existing line segment to remove it.</li>
                <li>This allows you to refine or correct your drawing at any time.</li>
            </ul>

            <div style="text-align:center; margin-top:18px;">
                <button onclick="showScreen('instructions')">Back</button>
                <button onclick="showScreen('instructions3')">Next</button>
            </div>

        </div>
    </div>
</div>

<!-- GLOBAL INSTRUCTIONS — SCREEN 3 -->
<div id="instructions3" class="screen">
    <div class="centered-container">
        <div class="instructions-container">

            <h2>Using Hints</h2>

            <h3>Hint Rules</h3>
            <ul>
                <li>You may use up to <strong>3 hints per round</strong>.</li>
                <li>Each hint reveals <strong>one correct edge</strong> from the target shape.</li>
                <li>There is a <strong>15-second cooldown</strong> before you may use the next hint.</li>
                <li>Hints are optional and using them will be recorded in your score.</li>
            </ul>

            <div style="text-align:center; margin-top:18px;">
                <button onclick="showScreen('instructions2')">Back</button>
                <button onclick="showScreen('instructions4')">Next</button>
            </div>

        </div>
    </div>
</div>
<!-- GLOBAL INSTRUCTIONS — SCREEN 4 -->
<div id="instructions4" class="screen">
    <div class="centered-container">
        <div class="instructions-container">

            <h2>Submitting Answers & Navigation</h2>

            <h3>Submitting Your Work</h3>
            <ul>
                <li>You can submit at any time — even if your drawing is incomplete or incorrect.</li>
                <li>Press the <strong>Submit</strong> button to finish the round.</li>
                <li>PolyMind records:
                    <ul>
                        <li>Correctness of your reconstruction</li>
                        <li>Time taken</li>
                        <li>Hints used</li>
                        <li>Missing or incorrect edges</li>
                        <li>Intersections or errors</li>
                    </ul>
                </li>
            </ul>

            <h3>Moving Through the Test</h3>
            <ul>
                <li>After each level, a results screen will appear.</li>
                <li>Use the button at the bottom of each results screen to proceed to the next level.</li>
                <li>The test becomes progressively more challenging.</li>
            </ul>

            <div style="text-align:center; margin-top:18px;">
                <button onclick="showScreen('instructions3')">Back</button>
                <button onclick="showScreen('level1Intro')">Start Level 1</button>
            </div>

        </div>
    </div>
</div>



<!-- LEVEL 1 INTRO -->
<div id="level1Intro" class="screen">
    <div class="centered-container">
        <div class="instructions-container">
            <h2>Level 1 – Shape Matching</h2>
            <div class="instructions-section">
                <h3>What you will see</h3>
                <ul>
                    <li>One shape on the left (the <strong>target shape</strong>).</li>
                    <li>Four shapes on the right (answer options).</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>Your task</h3>
                <ul>
                    <li>Choose the option on the right that is the same shape as the target.</li>
                    <li>The correct option may be <strong>flipped</strong> or <strong>rotated</strong>, but the shape itself is identical.</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>How to respond</h3>
                <ul>
                    <li>Click on one of the shapes on the right to select it (it will be highlighted).</li>
                    <li>Click <strong>Submit</strong> to record your answer.</li>
                </ul>
            </div>
            <div style="text-align:center; margin-top:12px;">
                <button onclick="startLevel1()">Start Level 1</button>
            </div>
        </div>
    </div>
</div>

<!-- LEVEL 1 -->
<div id="level1" class="screen">
    <div style="text-align:center;">
        <h2>Level 1</h2>
        <p id="levelText">Task: Choose the flipped shape</p>
    </div>
    <div id="questionContainer"></div>
    <div style="text-align:center;">
        <button onclick="submitAnswer()">Submit</button>
    </div>
</div>

<!-- LEVEL 1 RESULTS -->
<div id="results" class="screen">
    <div style="text-align:center; margin-top:5%">
        <h2>Level 1 Results</h2>
        <div id="summary" style="font-size:20px;"></div>
        <button onclick="showScreen('level2Intro')">Go to Level 2</button>
    </div>
</div>

<!-- LEVEL 2 INTRO -->
<div id="level2Intro" class="screen">
    <div class="centered-container">
        <div class="instructions-container">
            <h2>Level 2 – Labeled Polygon Reconstruction</h2>
            <div class="instructions-section">
                <h3>What you will see</h3>
                <ul>
                    <li>A shape is shown for <strong>5 seconds</strong>.</li>
                    <li>Then the shape disappears, and only the <strong>labeled points</strong> (1, 2, 3, …) remain.</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>Your task</h3>
                <ul>
                    <li>Reconstruct the shape by drawing edges between the labeled points.</li>
                    <li>Click the submit button once you are done.</li>
                </ul>
            </div>

            </div>
            <div style="text-align:center; margin-top:12px;">
                <button onclick="startLevel2()">Start Level 2</button>
                <button onclick="if(assessmentMode==='dev') showScreen('devLevelSelection'); else showScreen('level1Results');">Back</button>
            </div>
        </div>
    </div>
</div>

<!-- LEVEL 2 -->
<div id="level2" class="screen">
    <div style="text-align:center;">
        <h2>Level 2</h2>
        <p id="level2Text">Memorize the polygon.</p>
    </div>
    <div id="level2Container" style="display:flex; justify-content:center; margin-top:20px;"></div>
    <div style="text-align:center; margin-top:20px;">
        <button id="hintBtn" onclick="useHint()" disabled>Hint</button>
        <button id="submitL2Btn" onclick="submitLevel2()" disabled>Submit</button>
        <div id="hintInfo" style="margin-top:10px; font-size:14px; color:#555;"></div>
    </div>
</div>

<!-- LEVEL 2 RESULTS -->
<div id="results2" class="screen">
    <div style="text-align:center; margin-top:5%">
        <h2>Level 2 Results</h2>
        <div id="summary2" style="max-width:800px; margin:0 auto;"></div>
        <button onclick="showScreen('level3Intro')">Go to Level 3</button>
    </div>
</div>

<!-- LEVEL 3 INTRO -->
<div id="level3Intro" class="screen">
    <div class="centered-container">
        <div class="instructions-container">
            <h2>Level 3 – Unlabeled Polygon Reconstruction</h2>
            <div class="instructions-section">
                <h3>What you will see</h3>
                <ul>
                    <li>A shape shown for <strong>5 seconds</strong>.</li>
                    <li>Then the polygon disappears and only <strong>points (without any numbers)</strong> remain.</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>Your task</h3>
                <ul>
                    <li>Reconstruct the shape by connecting the points.</li>
                    <li>Click the submit button once you are done.</li>
                </ul>
            </div>

            <div style="text-align:center; margin-top:12px;">
                <button onclick="startLevel3()">Start Level 3</button>
                <button onclick="if(assessmentMode==='dev') showScreen('devLevelSelection'); else showScreen('results2');">Back</button>
            </div>
        </div>
    </div>
</div>

<!-- LEVEL 3 -->
<div id="level3" class="screen">
    <div style="text-align:center;">
        <h2>Level 3</h2>
        <p id="level3Text">Memorize the polygon.</p>
    </div>
    <div id="level3Container" style="display:flex; justify-content:center; margin-top:20px;"></div>
    <div style="text-align:center; margin-top:20px;">
        <button id="hintBtn3" onclick="useHint3()" disabled>Hint</button>
        <button id="submitL3Btn" onclick="submitLevel3()" disabled>Submit</button>
        <div id="hintInfo3" style="margin-top:10px; font-size:14px; color:#555;"></div>
    </div>
</div>

<!-- LEVEL 3 RESULTS -->
<div id="results3" class="screen">
    <div style="text-align:center; margin-top:5%">
        <h2>Level 3 Results</h2>
        <div id="summary3" style="max-width:800px; margin:0 auto;"></div>
        <button onclick="showScreen('level4Intro')">Go to Level 4</button>
    </div>
</div>

<!-- LEVEL 4 INTRO -->
<div id="level4Intro" class="screen">
    <div class="centered-container">
        <div class="instructions-container">
            <h2>Level 4 – Nested Shapes</h2>
            <div class="instructions-section">
                <h3>What you will see</h3>
                <ul>
                    <li>A larger shape with a smaller version of the same shape inside.</li>
                    <li>The two shapes will be shown together for <strong>5 seconds</strong>.</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>Your task</h3>
                <ul>
                    <li>Reconstruct <strong>both</strong> the outer and inner shapes by connecting the points.</li>
                    <li>Outer shape edges are drawn in <strong>black</strong>, inner shape edges in <strong>blue</strong>.</li>
                </ul>
            </div>

            <div style="text-align:center; margin-top:12px;">
                <button onclick="startLevel4()">Start Level 4</button>
                <button onclick="if(assessmentMode==='dev') showScreen('devLevelSelection'); else showScreen('results3');">Back</button>
            </div>
        </div>
    </div>
</div>

<!-- LEVEL 4 -->
<div id="level4" class="screen">
    <div style="text-align:center;">
        <h2>Level 4</h2>
        <p id="level4Text">Memorize the nested shapes.</p>
    </div>
    <div id="level4Container" style="display:flex; justify-content:center; margin-top:20px;"></div>
    <div style="text-align:center; margin-top:20px;">
        <button id="hintBtn4" onclick="useHint4()" disabled>Hint</button>
        <button id="submitL4Btn" onclick="submitLevel4()" disabled>Submit</button>
        <div id="hintInfo4" style="margin-top:10px; font-size:14px; color:#555;"></div>
    </div>
</div>

<!-- LEVEL 4 RESULTS -->
<div id="results4" class="screen">
    <div style="text-align:center; margin-top:5%">
        <h2>Level 4 Results</h2>
        <div id="summary4" style="max-width:800px; margin:0 auto;"></div>
        <button onclick="showScreen('level5Intro')">Go to Level 5</button>
    </div>
</div>

<!-- LEVEL 5 INTRO -->
<div id="level5Intro" class="screen">
    <div class="centered-container">
        <div class="instructions-container">
            <h2>Level 5 – Separate Triangles</h2>
            <div class="instructions-section">
                <h3>What you will see</h3>
                <ul>
                    <li>Some points will be given.</li>
                </ul>
            </div>
            <div class="instructions-section">
                <h3>Your task</h3>
                <ul>
                    <li>Create <strong>two separate triangles</strong> that do not touch each other.</li>
                    <li>The triangles must not share points, edges, or overlap.</li>
                    <li>The first triangle is drawn in <strong>black</strong>, the second in <strong>blue</strong>.</li>
                    <li>You do not have to use all the points.</li>
                </ul>
            </div>

            <div style="text-align:center; margin-top:12px;">
                <button onclick="startLevel5()">Start Level 5</button>
                <button onclick="if(assessmentMode==='dev') showScreen('devLevelSelection'); else showScreen('results4');">Back</button>
            </div>
        </div>
    </div>
</div>

<!-- LEVEL 5 -->
<div id="level5" class="screen">
    <div style="text-align:center;">
        <h2>Level 5</h2>
        <p id="level5Text">Create two separate triangles that do not touch.</p>
    </div>
    <div id="level5Container" style="display:flex; justify-content:center; margin-top:20px;"></div>
    <div style="text-align:center; margin-top:20px;">
        <button id="submitL5Btn" onclick="submitLevel5()">Submit</button>
        <div id="level5Info" style="margin-top:10px; font-size:14px; color:#555;">Draw your first triangle (black), then your second triangle (blue).</div>
    </div>
</div>

<!-- LEVEL 5 RESULTS -->
<div id="results5" class="screen">
    <div style="text-align:center; margin-top:5%">
        <h2>Level 5 Results</h2>
        <div id="summary5" style="max-width:800px; margin:0 auto;"></div>
        <button onclick="downloadCSV()">Download All Results (CSV)</button>
        <button onclick="alert('Assessment complete!')" style="margin-left:10px;">Finish</button>
    </div>
</div>

<script>
/* ============ GLOBAL STATE ============ */
let assessmentMode = 'physician'; // 'dev', 'physician', or 'patient'

/* ============ MODE SELECTION ============ */
function setMode(mode){
  assessmentMode = mode;
  if(mode === 'dev'){
    showScreen('devLevelSelection');
  } else {
    showScreen('intro');
  }
}

/* ============ UTILITIES ============ */
function shuffle(arr){
  return arr.map(v=>({v,sort:Math.random()}))
            .sort((a,b)=>a.sort-b.sort)
            .map(x=>x.v);
}

function showScreen(id){
  document.querySelectorAll(".screen").forEach(s=>s.classList.remove("active"));
  document.getElementById(id).classList.add("active");
}

function extractInner(full){
  return full.replace(/<svg[^>]*>/,"").replace("</svg>","");
}

/* ============ LEVEL 1 DATA ============ */
const flipProblems = [
  {target:`<polygon points="50,10 85,40 70,90 30,90 15,40"/>`,
   correct:`<g transform="scale(-1,1) translate(-100,0)"><polygon points="50,10 85,40 70,90 30,90 15,40"/></g>`},
  {target:`<polygon points="40,10 80,40 70,85 25,85 15,40"/>`,
   correct:`<g transform="scale(-1,1) translate(-100,0)"><polygon points="40,10 80,40 70,85 25,85 15,40"/></g>`},
  {target:`<polygon points="30,15 70,15 85,45 50,85 15,45"/>`,
   correct:`<g transform="scale(-1,1) translate(-100,0)"><polygon points="30,15 70,15 85,45 50,85 15,45"/></g>`}
];

const rotationProblems = [
  {target:`<polygon points="50,10 85,35 70,80 30,80 15,35"/>`,
   correct:`<g transform="rotate(90 50 50)"><polygon points="50,10 85,35 70,80 30,80 15,35"/></g>`},
  {target:`<polygon points="40,10 90,60 50,90 10,60"/>`,
   correct:`<g transform="rotate(60 50 50)"><polygon points="40,10 90,60 50,90 10,60"/></g>`}
];

const distractors = [
  `<polygon points="20,20 80,20 80,80 20,80"/>`,
  `<polygon points="50,15 85,75 15,75"/>`,
  `<polygon points="15,60 80,30 60,90"/>`
];

/* ============ LEVEL 1 STATE ============ */
let stage="flip";
let selectedElement=null;
let flipStart, flipEnd, rotationStart, rotationEnd;
let flipCorrect, rotationCorrect;
let flipCorrectSvg, rotationCorrectSvg;
let flipMistake=null, rotationMistake=null;
let flipLastActionTime=0, rotationLastActionTime=0;
let flipActionIntervals=[], rotationActionIntervals=[];
let level1Results = {flip: null, rotation: null};

/* ============ LEVEL 1 LOGIC ============ */
function startLevel1(){
  stage="flip";
  selectedElement=null;
  flipMistake=null;
  rotationMistake=null;
  flipStart = performance.now();
  flipLastActionTime = 0;
  flipActionIntervals = [];
  rotationLastActionTime = 0;
  rotationActionIntervals = [];
  document.getElementById("levelText").innerText = "Task: Choose the flipped shape";
  showScreen("level1");
  loadQuestion();
}

function loadQuestion(){
  selectedElement=null;

  const problem = stage==="flip"
    ? flipProblems[Math.floor(Math.random()*flipProblems.length)]
    : rotationProblems[Math.floor(Math.random()*rotationProblems.length)];

  if(stage==="flip") flipCorrectSvg = problem.correct;
  else rotationCorrectSvg = problem.correct;

  const options = shuffle([
    {svg: problem.correct, correct:true},
    ...shuffle(distractors).slice(0,3).map(d=>({svg:d, correct:false}))
  ]);

  document.getElementById("questionContainer").innerHTML = `
    <div class="question">
      <div class="panel">
        <svg width="260" height="260" viewBox="0 0 100 100" stroke="black" fill="none" stroke-width="3">
          ${problem.target}
        </svg>
      </div>
      <div class="panel">
        <div class="options">
          ${options.map(o => `
            <svg class="option"
                 width="160" height="160"
                 viewBox="0 0 100 100"
                 stroke="black" fill="none" stroke-width="3"
                 data-correct="${o.correct}"
                 onclick="selectOption(this)">
              ${o.svg}
            </svg>`).join("")}
        </div>
      </div>
    </div>`;
}

function selectOption(el){
  document.querySelectorAll(".option").forEach(s=>s.classList.remove("selected"));
  selectedElement = el;
  el.classList.add("selected");
  
  const now = performance.now();
  if(stage==="flip"){
    if(flipLastActionTime > 0){
      flipActionIntervals.push((now - flipLastActionTime)/1000);
    }
    flipLastActionTime = now;
  } else {
    if(rotationLastActionTime > 0){
      rotationActionIntervals.push((now - rotationLastActionTime)/1000);
    }
    rotationLastActionTime = now;
  }
}

function submitAnswer(){
  if(!selectedElement) return;
  const isCorrect = selectedElement.dataset.correct === "true";
  const now = performance.now();

  if(stage==="flip"){
    flipEnd = now;
    flipCorrect = isCorrect;
    if(flipLastActionTime > 0){
      flipActionIntervals.push((now - flipLastActionTime)/1000);
    }
    if(!isCorrect) flipMistake = selectedElement.outerHTML;
    stage = "rotation";
    rotationStart = performance.now();
    document.getElementById("levelText").innerText = "Task: Choose the rotated shape";
    loadQuestion();
  } else {
    rotationEnd = now;
    rotationCorrect = isCorrect;
    if(rotationLastActionTime > 0){
      rotationActionIntervals.push((now - rotationLastActionTime)/1000);
    }
    if(!isCorrect) rotationMistake = selectedElement.outerHTML;
    endLevel1();
  }
}

function endLevel1(){
  const flipTime = ((flipEnd - flipStart)/1000).toFixed(2);
  const rotationTime = ((rotationEnd - rotationStart)/1000).toFixed(2);
  
  const flipAvgInterval = flipActionIntervals.length > 0 
    ? (flipActionIntervals.reduce((a,b)=>a+b,0) / flipActionIntervals.length).toFixed(2)
    : "N/A";
  const flipTimeBeforeSubmit = flipActionIntervals.length > 0
    ? flipActionIntervals[flipActionIntervals.length - 1].toFixed(2)
    : "N/A";
    
  const rotationAvgInterval = rotationActionIntervals.length > 0
    ? (rotationActionIntervals.reduce((a,b)=>a+b,0) / rotationActionIntervals.length).toFixed(2)
    : "N/A";
  const rotationTimeBeforeSubmit = rotationActionIntervals.length > 0
    ? rotationActionIntervals[rotationActionIntervals.length - 1].toFixed(2)
    : "N/A";

  // Store results
  level1Results.flip = {
    correct: flipCorrect,
    time: flipTime,
    avgActionInterval: flipAvgInterval,
    timeBeforeSubmit: flipTimeBeforeSubmit
  };
  level1Results.rotation = {
    correct: rotationCorrect,
    time: rotationTime,
    avgActionInterval: rotationAvgInterval,
    timeBeforeSubmit: rotationTimeBeforeSubmit
  };

  let html = `
    <h3 style="text-align:center;">Round 1 — Flip</h3>
    <table class="results-table">
      <tr><td>Result</td><td>${flipCorrect ? "Correct" : "Wrong"}</td></tr>
      <tr><td>Time Taken</td><td>${flipTime} sec</td></tr>
      <tr><td>Avg Time Between Actions</td><td>${flipAvgInterval} sec</td></tr>
      <tr><td>Time Before Submit</td><td>${flipTimeBeforeSubmit} sec</td></tr>
    </table>
  `;

  if(flipMistake) {
    html += `
      <div class="resultShapes">
        <div>
          Original:<br>
          <svg viewBox="0 0 100 100" width="160" height="160" stroke="black" fill="none" stroke-width="3">
            ${flipCorrectSvg}
          </svg>
        </div>
        <div>
          Mistake:<br>
          <svg viewBox="0 0 100 100" width="160" height="160" stroke="black" fill="none" stroke-width="3">
            ${extractInner(flipMistake)}
          </svg>
        </div>
      </div>
    `;
  }

  html += `
    <h3 style="text-align:center;">Round 2 — Rotation</h3>
    <table class="results-table">
      <tr><td>Result</td><td>${rotationCorrect ? "Correct" : "Wrong"}</td></tr>
      <tr><td>Time Taken</td><td>${rotationTime} sec</td></tr>
      <tr><td>Avg Time Between Actions</td><td>${rotationAvgInterval} sec</td></tr>
      <tr><td>Time Before Submit</td><td>${rotationTimeBeforeSubmit} sec</td></tr>
    </table>
  `;

  if(rotationMistake) {
    html += `
      <div class="resultShapes">
        <div>
          Original:<br>
          <svg viewBox="0 0 100 100" width="160" height="160" stroke="black" fill="none" stroke-width="3">
            ${rotationCorrectSvg}
          </svg>
        </div>
        <div>
          Mistake:<br>
          <svg viewBox="0 0 100 100" width="160" height="160" stroke="black" fill="none" stroke-width="3">
            ${extractInner(rotationMistake)}
          </svg>
        </div>
      </div>
    `;
  }

  document.getElementById("summary").innerHTML = html;
  if(assessmentMode === 'patient'){
    showScreen('level2Intro');
  } else {
    showScreen("results");
  }
}

/* ============ LEVEL 2 DATA ============ */
const level2Polygons = [
  {
    vertices: [
      {x:20,y:20},{x:80,y:20},{x:90,y:50},
      {x:70,y:85},{x:30,y:85},{x:10,y:50}
    ]
  },
  {
    vertices: [
      {x:25,y:15},{x:75,y:15},{x:90,y:45},
      {x:70,y:80},{x:40,y:90},{x:15,y:60},{x:15,y:35}
    ]
  }
];

/* ============ LEVEL 2 STATE ============ */
let l2RoundIndex = 0;
let l2Results = [];
let l2CurrentEdges = [];   // {i,j,viaHint}
let l2EdgeHistory = [];    // for order metric
let l2HintsUsed = 0;
let l2LastHintTime = 0;
let l2ErasedEdges = 0;
let l2DragStartIndex = null;
let l2RoundStartTime = 0;
let l2ViewingTimeoutId = null;
let l2LastActionTime = 0;
let l2ActionIntervals = [];

/* ============ LEVEL 2 FLOW ============ */
function startLevel2(){
  l2RoundIndex = 0;
  l2Results = [];
  showScreen("level2");
  startLevel2Round();
}

function startLevel2Round(){
  const poly = level2Polygons[l2RoundIndex];
  const vertices = poly.vertices;

  l2CurrentEdges = [];
  l2EdgeHistory = [];
  l2HintsUsed = 0;
  l2LastHintTime = 0;
  l2ErasedEdges = 0;
  l2DragStartIndex = null;
  l2LastActionTime = 0;
  l2ActionIntervals = [];

  const hintBtn = document.getElementById("hintBtn");
  const submitBtn = document.getElementById("submitL2Btn");
  const hintInfo = document.getElementById("hintInfo");

  hintBtn.disabled = true;
  submitBtn.disabled = true;
  hintInfo.textContent = "Memorize the polygon (5 seconds).";
  document.getElementById("level2Text").textContent = "Memorize the polygon.";

  document.getElementById("level2Container").innerHTML = `
    <svg id="level2Svg" viewBox="0 0 100 100" width="400" height="400">
      <polygon points="${vertices.map(v=>`${v.x},${v.y}`).join(" ")}"
               fill="none" stroke="black" stroke-width="2"/>
    </svg>
  `;

  if(l2ViewingTimeoutId) clearTimeout(l2ViewingTimeoutId);
  l2ViewingTimeoutId = setTimeout(()=> {
    startReconstruction(vertices);
  }, 5000);
}

function startReconstruction(vertices){
  document.getElementById("level2Text").textContent = "Reconstruct the polygon.";
  document.getElementById("hintBtn").disabled = false;
  document.getElementById("submitL2Btn").disabled = false;
  document.getElementById("hintInfo").textContent = "You can use up to 3 hints (15s gap).";

  l2RoundStartTime = performance.now();
  renderLevel2Svg(vertices);
}

function renderLevel2Svg(vertices){
  const container = document.getElementById("level2Container");

  const linesHtml = l2CurrentEdges.map((e,idx)=>{
    const a=vertices[e.i], b=vertices[e.j];
    return `<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}"
                  stroke="black" stroke-width="2"
                  data-index="${idx}" />`;
  }).join("");

  const pointsHtml = vertices.map((v,idx)=>`
    <g>
      <circle cx="${v.x}" cy="${v.y}" r="3.5" fill="black"
              data-vertex="${idx}"
              style="cursor:pointer; pointer-events:auto;" />
      <text x="${v.x+3}" y="${v.y-3}" font-size="5" fill="black">${idx+1}</text>
    </g>`).join("");

  container.innerHTML = `
    <svg id="level2Svg" viewBox="0 0 100 100" width="400" height="400">
      ${linesHtml}
      ${pointsHtml}
    </svg>
  `;

  const svg = document.getElementById("level2Svg");

  svg.querySelectorAll("line").forEach(line=>{
    line.addEventListener("click", ()=>{
      const index = parseInt(line.getAttribute("data-index"),10);
      if(!isNaN(index)){
        l2CurrentEdges.splice(index,1);
        l2ErasedEdges++;
        
        const now = performance.now();
        if(l2LastActionTime > 0){
          l2ActionIntervals.push((now - l2LastActionTime)/1000);
        }
        l2LastActionTime = now;
        
        renderLevel2Svg(vertices);
      }
    });
  });

  svg.querySelectorAll("circle").forEach(circle=>{
    const idx = parseInt(circle.getAttribute("data-vertex"),10);

    circle.addEventListener("mousedown", ()=>{
      l2DragStartIndex = idx;
    });

    circle.addEventListener("mouseup", ()=>{
      if(l2DragStartIndex !== null && l2DragStartIndex !== idx){
        addL2Edge(l2DragStartIndex, idx, vertices, false);
      }
      l2DragStartIndex = null;
    });
  });
}

function addL2Edge(i,j,vertices, viaHint){
  if(l2CurrentEdges.some(e => (e.i===i && e.j===j) || (e.i===j && e.j===i))) return;
  l2CurrentEdges.push({i,j,viaHint});
  l2EdgeHistory.push({i,j,viaHint});
  
  const now = performance.now();
  if(l2LastActionTime > 0){
    l2ActionIntervals.push((now - l2LastActionTime)/1000);
  }
  l2LastActionTime = now;
  
  renderLevel2Svg(vertices);
}

function useHint(){
  const now = Date.now();
  const hintInfo = document.getElementById("hintInfo");
  const poly = level2Polygons[l2RoundIndex];
  const vertices = poly.vertices;
  const n = vertices.length;

  if(l2HintsUsed >= 3){
    hintInfo.textContent = "Maximum hints used.";
    return;
  }
  if(l2LastHintTime && now - l2LastHintTime < 15000){
    const remain = Math.ceil((15000 - (now - l2LastHintTime))/1000);
    hintInfo.textContent = `Next hint in ${remain}s`;
    return;
  }

  const trueEdges = [];
  for(let k=0;k<n;k++){
    const a=k, b=(k+1)%n;
    const ii=Math.min(a,b), jj=Math.max(a,b);
    trueEdges.push({i:ii,j:jj});
  }

  let chosen=null;
  for(const e of trueEdges){
    if(!l2CurrentEdges.some(x=>{
      const xi=Math.min(x.i,x.j), xj=Math.max(x.i,x.j);
      return xi===e.i && xj===e.j;
    })){
      chosen=e; break;
    }
  }

  if(!chosen){
    hintInfo.textContent = "All edges already revealed.";
    return;
  }

  l2HintsUsed++;
  l2LastHintTime = now;
  let start = chosen.i;
  let end   = chosen.j;
  addL2Edge(start, end, vertices, true);
  hintInfo.textContent = `Hints used: ${l2HintsUsed}/3`;
}

/* -------- L2 helpers -------- */
function isClosedPolygonL2(vertices){
  const n = vertices.length;
  if(l2CurrentEdges.length === 0) return false;
  const deg = Array(n).fill(0);
  for(const e of l2CurrentEdges){
    deg[e.i]++; deg[e.j]++;
  }
  return deg.every(d => d >= 2);
}

function checkFollowOrder(n){
  const seq = l2EdgeHistory.filter(e => !e.viaHint);
  if(seq.length === 0) return false;

  for(let s0=0; s0<n; s0++){
    let ok = true;
    for(let k=0; k<seq.length; k++){
      const expectedStart = (s0 + k) % n;
      const expectedEnd   = (expectedStart + 1) % n;
      const e = seq[k];
      if(e.i !== expectedStart || e.j !== expectedEnd){
        ok = false; break;
      }
    }
    if(ok) return true;
  }
  return false;
}

function segmentsIntersect(p1,p2,p3,p4){
  function orient(p,q,r){
    const val = (q.y-p.y)*(r.x-q.x) - (q.x-p.x)*(r.y-q.y);
    if(val===0) return 0;
    return val>0 ? 1 : 2;
  }
  const o1=orient(p1,p2,p3);
  const o2=orient(p1,p2,p4);
  const o3=orient(p3,p4,p1);
  const o4=orient(p3,p4,p2);
  if(o1!==o2 && o3!==o4) return true;
  return false;
}

function edgesIntersect(e1,e2,vertices){
  const a=e1.i,b=e1.j,c=e2.i,d=e2.j;
  if(a===c||a===d||b===c||b===d) return false;
  const p1=vertices[a], p2=vertices[b], p3=vertices[c], p4=vertices[d];
  return segmentsIntersect(p1,p2,p3,p4);
}

function submitLevel2(){
  const poly = level2Polygons[l2RoundIndex];
  const vertices = poly.vertices;
  const n = vertices.length;

  const end = performance.now();
  const timeTaken = ((end - l2RoundStartTime)/1000).toFixed(2);

  const trueEdges = [];
  for(let k=0;k<n;k++){
    const a=k, b=(k+1)%n;
    const ii=Math.min(a,b), jj=Math.max(a,b);
    trueEdges.push(`${ii}-${jj}`);
  }
  const trueSet = new Set(trueEdges);

  const userEdges = l2CurrentEdges.map(e=>{
    const ii=Math.min(e.i,e.j), jj=Math.max(e.i,e.j);
    return `${ii}-${jj}`;
  });
  const userSet = new Set(userEdges);

  let missing=0, wrong=0;
  for(const t of trueEdges) if(!userSet.has(t)) missing++;
  for(const u of userEdges) if(!trueSet.has(u)) wrong++;

  let intersect=false;
  for(let i=0;i<l2CurrentEdges.length;i++){
    for(let j=i+1;j<l2CurrentEdges.length;j++){
      if(edgesIntersect(l2CurrentEdges[i],l2CurrentEdges[j],vertices)){
        intersect = true; break;
      }
    }
    if(intersect) break;
  }

  const closed = isClosedPolygonL2(vertices);
  const followOrder = checkFollowOrder(n);
  const correct = (missing===0 && wrong===0 && !intersect && closed);
  
  const now = performance.now();
  if(l2LastActionTime > 0){
    l2ActionIntervals.push((now - l2LastActionTime)/1000);
  }
  
  const avgInterval = l2ActionIntervals.length > 0
    ? (l2ActionIntervals.reduce((a,b)=>a+b,0) / l2ActionIntervals.length).toFixed(2)
    : 0;
  const timeBeforeSubmit = l2ActionIntervals.length > 0
    ? l2ActionIntervals[l2ActionIntervals.length - 1].toFixed(2)
    : 0;

  l2Results.push({
    correct,
    time: timeTaken,
    hints: l2HintsUsed,
    missing,
    wrong,
    intersect,
    erased: l2ErasedEdges,
    followOrder,
    closed,
    avgActionInterval: avgInterval,
    timeBeforeSubmit: timeBeforeSubmit
  });

  if(l2RoundIndex === level2Polygons.length - 1){
    endLevel2();
  } else {
    l2RoundIndex++;
    startLevel2Round();
  }
}

function endLevel2(){
  let html = "";
  l2Results.forEach((r,i)=>{
    html += `
      <h3 style="text-align:center;">Round ${i+1}</h3>
      <table class="results-table">
        <tr><td>Result</td><td>${r.correct ? "Correct" : "Wrong"}</td></tr>
        <tr><td>Time Taken</td><td>${r.time} sec</td></tr>
        <tr><td>Hints Used</td><td>${r.hints}</td></tr>
        <tr><td>Edges Missing</td><td>${r.missing}</td></tr>
        <tr><td>Edges Wrong</td><td>${r.wrong}</td></tr>
        <tr><td>Any Intersections</td><td>${r.intersect ? "Yes" : "No"}</td></tr>
        <tr><td>Closed Shape</td><td>${r.closed ? "Yes" : "No"}</td></tr>
        <tr><td>Edges Erased</td><td>${r.erased}</td></tr>
        <tr><td>Followed Label Order</td><td>${r.followOrder ? "Yes" : "No"}</td></tr>
        <tr><td>Avg Time Between Actions</td><td>${r.avgActionInterval} sec</td></tr>
        <tr><td>Time Before Submit</td><td>${r.timeBeforeSubmit} sec</td></tr>
      </table>
    `;
  });

  document.getElementById("summary2").innerHTML = html;
  if(assessmentMode === 'patient'){
    showScreen('level3Intro');
  } else {
    showScreen("results2");
  }
}

/* ============ LEVEL 5 DATA (multi-shape construction) ============ */
const level5PointSets = [
  {
    // 12 scattered points
    points: [
      {x:15,y:20}, {x:35,y:15}, {x:25,y:35},
      {x:50,y:25}, {x:60,y:10}, {x:70,y:30},
      {x:20,y:65}, {x:40,y:70}, {x:30,y:85},
      {x:75,y:60}, {x:85,y:75}, {x:90,y:50}
    ]
  },
  {
    // 15 scattered points with more options
    points: [
      {x:10,y:15}, {x:25,y:10}, {x:20,y:25}, {x:35,y:20},
      {x:45,y:12}, {x:55,y:22}, {x:65,y:15}, {x:75,y:25},
      {x:15,y:50}, {x:30,y:55}, {x:40,y:45},
      {x:60,y:70}, {x:75,y:65}, {x:85,y:80}, {x:70,y:85}
    ]
  }
];

/* ============ LEVEL 4 DATA (nested shapes) ============ */
const level4Shapes = [
  {
    // Simple shape: Square within square
    name: "square",
    outer: [
      {x:10,y:10}, {x:90,y:10}, {x:90,y:90}, {x:10,y:90}
    ],
    inner: [
      {x:30,y:30}, {x:70,y:30}, {x:70,y:70}, {x:30,y:70}
    ]
  },
  {
    // Simple shape: Triangle within triangle
    name: "triangle",
    outer: [
      {x:50,y:5}, {x:95,y:85}, {x:5,y:85}
    ],
    inner: [
      {x:50,y:30}, {x:70,y:65}, {x:30,y:65}
    ]
  },
  {
    // Simple shape: Pentagon within pentagon
    name: "pentagon",
    outer: [
      {x:50,y:8}, {x:90,y:35}, {x:75,y:85}, {x:25,y:85}, {x:10,y:35}
    ],
    inner: [
      {x:50,y:30}, {x:70,y:45}, {x:62,y:68}, {x:38,y:68}, {x:30,y:45}
    ]
  },
  {
    // Simple shape: Rectangle within rectangle
    name: "rectangle",
    outer: [
      {x:15,y:20}, {x:85,y:20}, {x:85,y:80}, {x:15,y:80}
    ],
    inner: [
      {x:35,y:38}, {x:65,y:38}, {x:65,y:62}, {x:35,y:62}
    ]
  },
  {
    // Complex shape: 5-pointed star within star
    name: "star",
    outer: [
      {x:50,y:5}, {x:58,y:35}, {x:90,y:35}, {x:65,y:55},
      {x:75,y:85}, {x:50,y:65}, {x:25,y:85}, {x:35,y:55},
      {x:10,y:35}, {x:42,y:35}
    ],
    inner: [
      {x:50,y:25}, {x:54,y:40}, {x:68,y:40}, {x:57,y:48},
      {x:61,y:62}, {x:50,y:53}, {x:39,y:62}, {x:43,y:48},
      {x:32,y:40}, {x:46,y:40}
    ]
  },
  {
    // Complex shape: Concave arrow-like shape
    name: "concave",
    outer: [
      {x:20,y:20}, {x:80,y:20}, {x:80,y:45}, {x:50,y:45},
      {x:50,y:80}, {x:35,y:80}, {x:35,y:45}, {x:20,y:45}
    ],
    inner: [
      {x:35,y:30}, {x:65,y:30}, {x:65,y:40}, {x:48,y:40},
      {x:48,y:65}, {x:42,y:65}, {x:42,y:40}, {x:35,y:40}
    ]
  },
  {
    // Complex shape: Tree (T-shape) within tree
    name: "tree",
    outer: [
      {x:20,y:15}, {x:80,y:15}, {x:80,y:35}, {x:60,y:35},
      {x:60,y:85}, {x:40,y:85}, {x:40,y:35}, {x:20,y:35}
    ],
    inner: [
      {x:35,y:28}, {x:65,y:28}, {x:65,y:38}, {x:55,y:38},
      {x:55,y:68}, {x:45,y:68}, {x:45,y:38}, {x:35,y:38}
    ]
  }
];

/* ============ LEVEL 3 DATA (more complex polygons) ============ */
const level3Polygons = [
  {
    // 10 vertices, 3 concave points
    vertices: [
      {x:18,y:12}, {x:60,y:10}, {x:90,y:28}, 
      {x:83,y:50}, {x:95,y:70}, 
      {x:72,y:88}, {x:42,y:95}, 
      {x:28,y:80}, {x:35,y:58},  // concave inward
      {x:12,y:40}                // concave inward
    ]
  },
  {
    // 9 vertices, multiple reflex angles
    vertices: [
      {x:20,y:18}, {x:55,y:12}, {x:88,y:22}, 
      {x:92,y:48},
      {x:78,y:78}, {x:48,y:92},
      {x:28,y:74}, {x:18,y:60}, 
      {x:30,y:42} // deep concave
    ]
  }
];

/* ============ LEVEL 3 STATE ============ */
let l3RoundIndex = 0;
let l3Results = [];
let l3CurrentEdges = [];
let l3HintsUsed = 0;
let l3LastHintTime = 0;
let l3ErasedEdges = 0;
let l3DragStartIndex = null;
let l3RoundStartTime = 0;
let l3ViewingTimeoutId = null;
let l3LastActionTime = 0;
let l3ActionIntervals = [];

/* ============ LEVEL 4 STATE ============ */
let l4RoundIndex = 0;
let l4Results = [];
let l4CurrentEdges = [];  // will track which shape each edge belongs to
let l4HintsUsed = 0;
let l4LastHintTime = 0;
let l4ErasedEdges = 0;
let l4DragStartIndex = null;
let l4RoundStartTime = 0;
let l4ViewingTimeoutId = null;
let l4LastActionTime = 0;
let l4ActionIntervals = [];
let l4CurrentShapeIndices = [];  // indices into level4Shapes for current round

/* ============ LEVEL 5 STATE ============ */
let l5RoundIndex = 0;
let l5Results = [];
let l5CurrentEdges = [];  // {i, j, triangleNum} - triangleNum is 1 or 2
let l5DragStartIndex = null;
let l5RoundStartTime = 0;
let l5LastActionTime = 0;
let l5ActionIntervals = [];
let l5ErasedEdges = 0;

/* ============ LEVEL 3 FLOW ============ */
function startLevel3(){
  l3RoundIndex = 0;
  l3Results = [];
  showScreen("level3");
  startLevel3Round();
}

function startLevel3Round(){
  const poly = level3Polygons[l3RoundIndex];
  const vertices = poly.vertices;

  l3CurrentEdges = [];
  l3HintsUsed = 0;
  l3LastHintTime = 0;
  l3ErasedEdges = 0;
  l3DragStartIndex = null;
  l3LastActionTime = 0;
  l3ActionIntervals = [];

  const hintBtn = document.getElementById("hintBtn3");
  const submitBtn = document.getElementById("submitL3Btn");
  const hintInfo = document.getElementById("hintInfo3");

  hintBtn.disabled = true;
  submitBtn.disabled = true;
  hintInfo.textContent = "Memorize the polygon (5 seconds).";
  document.getElementById("level3Text").textContent = "Memorize the polygon.";

  document.getElementById("level3Container").innerHTML = `
    <svg id="level3Svg" viewBox="0 0 100 100" width="400" height="400">
      <polygon points="${vertices.map(v=>`${v.x},${v.y}`).join(" ")}"
               fill="none" stroke="black" stroke-width="2"/>
    </svg>
  `;

  if(l3ViewingTimeoutId) clearTimeout(l3ViewingTimeoutId);
  l3ViewingTimeoutId = setTimeout(()=> {
    startL3Reconstruction(vertices);
  }, 5000);
}

function startL3Reconstruction(vertices){
  document.getElementById("level3Text").textContent = "Reconstruct the polygon.";
  document.getElementById("hintBtn3").disabled = false;
  document.getElementById("submitL3Btn").disabled = false;
  document.getElementById("hintInfo3").textContent = "You can use up to 3 hints (15s gap).";

  l3RoundStartTime = performance.now();
  renderLevel3Svg(vertices);
}

function renderLevel3Svg(vertices){
  const container = document.getElementById("level3Container");

  const linesHtml = l3CurrentEdges.map((e,idx)=>{
    const a=vertices[e.i], b=vertices[e.j];
    return `<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}"
                  stroke="black" stroke-width="2"
                  data-index="${idx}" />`;
  }).join("");

  const pointsHtml = vertices.map((v,idx)=>`
    <circle cx="${v.x}" cy="${v.y}" r="3.5" fill="black"
            data-vertex="${idx}"
            style="cursor:pointer; pointer-events:auto;" />
  `).join("");

  container.innerHTML = `
    <svg id="level3Svg" viewBox="0 0 100 100" width="400" height="400">
      ${linesHtml}
      ${pointsHtml}
    </svg>
  `;

  const svg = document.getElementById("level3Svg");

  svg.querySelectorAll("line").forEach(line=>{
    line.addEventListener("click", ()=>{
      const index = parseInt(line.getAttribute("data-index"),10);
      if(!isNaN(index)){
        l3CurrentEdges.splice(index,1);
        l3ErasedEdges++;
        
        const now = performance.now();
        if(l3LastActionTime > 0){
          l3ActionIntervals.push((now - l3LastActionTime)/1000);
        }
        l3LastActionTime = now;
        
        renderLevel3Svg(vertices);
      }
    });
  });

  svg.querySelectorAll("circle").forEach(circle=>{
    const idx = parseInt(circle.getAttribute("data-vertex"),10);

    circle.addEventListener("mousedown", ()=>{
      l3DragStartIndex = idx;
    });

    circle.addEventListener("mouseup", ()=>{
      if(l3DragStartIndex !== null && l3DragStartIndex !== idx){
        addL3Edge(l3DragStartIndex, idx, vertices);
      }
      l3DragStartIndex = null;
    });
  });
}

function addL3Edge(i,j,vertices){
  if(l3CurrentEdges.some(e => (e.i===i && e.j===j) || (e.i===j && e.j===i))) return;
  l3CurrentEdges.push({i,j});
  
  const now = performance.now();
  if(l3LastActionTime > 0){
    l3ActionIntervals.push((now - l3LastActionTime)/1000);
  }
  l3LastActionTime = now;
  
  renderLevel3Svg(vertices);
}

function useHint3(){
  const now = Date.now();
  const hintInfo = document.getElementById("hintInfo3");
  const poly = level3Polygons[l3RoundIndex];
  const vertices = poly.vertices;
  const n = vertices.length;

  if(l3HintsUsed >= 3){
    hintInfo.textContent = "Maximum hints used.";
    return;
  }
  if(l3LastHintTime && now - l3LastHintTime < 15000){
    const remain = Math.ceil((15000 - (now - l3LastHintTime))/1000);
    hintInfo.textContent = `Next hint in ${remain}s`;
    return;
  }

  const trueEdges = [];
  for(let k=0;k<n;k++){
    const a=k, b=(k+1)%n;
    const ii=Math.min(a,b), jj=Math.max(a,b);
    trueEdges.push({i:ii,j:jj});
  }

  let chosen=null;
  for(const e of trueEdges){
    if(!l3CurrentEdges.some(x=>{
      const xi=Math.min(x.i,x.j), xj=Math.max(x.i,x.j);
      return xi===e.i && xj===e.j;
    })){
      chosen=e; break;
    }
  }

  if(!chosen){
    hintInfo.textContent = "All edges already revealed.";
    return;
  }

  l3HintsUsed++;
  l3LastHintTime = now;
  addL3Edge(chosen.i, chosen.j, vertices);
  hintInfo.textContent = `Hints used: ${l3HintsUsed}/3`;
}

function isClosedPolygonL3(vertices){
  const n = vertices.length;
  if(l3CurrentEdges.length === 0) return false;
  const deg = Array(n).fill(0);
  for(const e of l3CurrentEdges){
    deg[e.i]++; deg[e.j]++;
  }
  return deg.every(d => d >= 2);
}

function submitLevel3(){
  const poly = level3Polygons[l3RoundIndex];
  const vertices = poly.vertices;
  const n = vertices.length;

  const end = performance.now();
  const timeTaken = ((end - l3RoundStartTime)/1000).toFixed(2);

  const trueEdges = [];
  for(let k=0;k<n;k++){
    const a=k, b=(k+1)%n;
    const ii=Math.min(a,b), jj=Math.max(a,b);
    trueEdges.push(`${ii}-${jj}`);
  }
  const trueSet = new Set(trueEdges);

  const userEdges = l3CurrentEdges.map(e=>{
    const ii=Math.min(e.i,e.j), jj=Math.max(e.i,e.j);
    return `${ii}-${jj}`;
  });
  const userSet = new Set(userEdges);

  let missing=0, wrong=0;
  for(const t of trueEdges) if(!userSet.has(t)) missing++;
  for(const u of userEdges) if(!trueSet.has(u)) wrong++;

  let intersect=false;
  for(let i=0;i<l3CurrentEdges.length;i++){
    for(let j=i+1;j<l3CurrentEdges.length;j++){
      if(edgesIntersect(l3CurrentEdges[i],l3CurrentEdges[j],vertices)){
        intersect = true; break;
      }
    }
    if(intersect) break;
  }

  const closed = isClosedPolygonL3(vertices);
  const correct = (missing===0 && wrong===0 && !intersect && closed);
  
  const now = performance.now();
  if(l3LastActionTime > 0){
    l3ActionIntervals.push((now - l3LastActionTime)/1000);
  }
  
  const avgInterval = l3ActionIntervals.length > 0
    ? (l3ActionIntervals.reduce((a,b)=>a+b,0) / l3ActionIntervals.length).toFixed(2)
    : 0;
  const timeBeforeSubmit = l3ActionIntervals.length > 0
    ? l3ActionIntervals[l3ActionIntervals.length - 1].toFixed(2)
    : 0;

  l3Results.push({
    correct,
    time: timeTaken,
    hints: l3HintsUsed,
    missing,
    wrong,
    intersect,
    erased: l3ErasedEdges,
    closed,
    avgActionInterval: avgInterval,
    timeBeforeSubmit: timeBeforeSubmit
  });

  if(l3RoundIndex === level3Polygons.length - 1){
    endLevel3();
  } else {
    l3RoundIndex++;
    startLevel3Round();
  }
}

function endLevel3(){
  let html = "";
  l3Results.forEach((r,i)=>{
    html += `
      <h3 style="text-align:center;">Round ${i+1}</h3>
      <table class="results-table">
        <tr><td>Result</td><td>${r.correct ? "Correct" : "Wrong"}</td></tr>
        <tr><td>Time Taken</td><td>${r.time} sec</td></tr>
        <tr><td>Hints Used</td><td>${r.hints}</td></tr>
        <tr><td>Edges Missing</td><td>${r.missing}</td></tr>
        <tr><td>Edges Wrong</td><td>${r.wrong}</td></tr>
        <tr><td>Any Intersections</td><td>${r.intersect ? "Yes" : "No"}</td></tr>
        <tr><td>Closed Shape</td><td>${r.closed ? "Yes" : "No"}</td></tr>
        <tr><td>Edges Erased</td><td>${r.erased}</td></tr>
        <tr><td>Avg Time Between Actions</td><td>${r.avgActionInterval} sec</td></tr>
        <tr><td>Time Before Submit</td><td>${r.timeBeforeSubmit} sec</td></tr>
      </table>
    `;
  });

  document.getElementById("summary3").innerHTML = html;
  if(assessmentMode === 'patient'){
    showScreen('level4Intro');
  } else {
    showScreen("results3");
  }
}

/* ============ LEVEL 4 FLOW ============ */

function startLevel4(){
    l4RoundIndex = 0;
    l4Results = [];
    showScreen("level4");
    startLevel4Round();
}

function startLevel4Round(){

    // Round 1 = simple shape, Round 2 = complex shape
    const simpleShapes = [0, 1, 2, 3];       // e.g., square, triangle, pentagon, rectangle  
    const complexShapes = [4, 5, 6];         // e.g., star, concave, nested tree

    const shapeIndex =
        l4RoundIndex === 0
        ? simpleShapes[Math.floor(Math.random() * simpleShapes.length)]
        : complexShapes[Math.floor(Math.random() * complexShapes.length)];

    const shape = level4Shapes[shapeIndex];

    const outerVertices = shape.outer;
    const innerVertices = shape.inner;
    const totalVertices = [...outerVertices, ...innerVertices];

    // Reset state
    l4CurrentEdges = [];
    l4HintsUsed = 0;
    l4LastHintTime = 0;
    l4ErasedEdges = 0;
    l4DragStartIndex = null;
    l4LastActionTime = 0;
    l4ActionIntervals = [];
    l4CurrentShapeIndices = [shapeIndex];

    const hintBtn = document.getElementById("hintBtn4");
    const submitBtn = document.getElementById("submitL4Btn");
    const hintInfo = document.getElementById("hintInfo4");

    hintBtn.disabled = true;
    submitBtn.disabled = true;
    hintInfo.textContent = "Memorize the nested shapes (5 seconds).";

    document.getElementById("level4Text").textContent =
        `Memorize the nested shapes (${l4RoundIndex === 0 ? "Simple" : "Complex"}).`;

    // Build SVG polygons
    const outerPoints = outerVertices.map(v => `${v.x},${v.y}`).join(" ");
    const innerPoints = innerVertices.map(v => `${v.x},${v.y}`).join(" ");

    document.getElementById("level4Container").innerHTML = `
        <svg id="level4Svg" viewBox="0 0 100 100" width="500" height="500">
            <polygon points="${outerPoints}" fill="none" stroke="black" stroke-width="2"/>
            <polygon points="${innerPoints}" fill="none" stroke="blue"  stroke-width="2"/>
        </svg>
    `;

    if(l4ViewingTimeoutId) clearTimeout(l4ViewingTimeoutId);

    l4ViewingTimeoutId = setTimeout(() => {
        startL4Reconstruction(totalVertices, outerVertices.length);
    }, 5000);
}

function startL4Reconstruction(vertices, outerCount){

    document.getElementById("level4Text").textContent =
        "Reconstruct both the outer (black) and inner (blue) shapes.";

    document.getElementById("hintBtn4").disabled = false;
    document.getElementById("submitL4Btn").disabled = false;

    document.getElementById("hintInfo4").textContent =
        "You can use up to 3 hints (15s gap). Black dots = outer shape, Blue dots = inner shape.";

    l4RoundStartTime = performance.now();

    renderLevel4Svg(vertices, outerCount);
}

function renderLevel4Svg(vertices, outerCount){

    const container = document.getElementById("level4Container");

    const linesHtml = l4CurrentEdges.map((e, idx) => {
        const a = vertices[e.i];
        const b = vertices[e.j];
        const color = e.isOuter ? "black" : "blue";

        return `
            <line x1="${a.x}" y1="${a.y}"
                  x2="${b.x}" y2="${b.y}"
                  stroke="${color}" stroke-width="2"
                  data-index="${idx}" />
        `;
    }).join("");

    const pointsHtml = vertices.map((v, idx) => {
        const isOuter = idx < outerCount;
        const color = isOuter ? "black" : "blue";

        return `
            <circle cx="${v.x}" cy="${v.y}" r="3.5"
                    fill="${color}" data-vertex="${idx}"
                    style="cursor:pointer; pointer-events:auto;" />
        `;
    }).join("");

    container.innerHTML = `
        <svg id="level4Svg" viewBox="0 0 100 100" width="500" height="500">
            ${linesHtml}
            ${pointsHtml}
        </svg>
    `;

    const svg = document.getElementById("level4Svg");

    // Erase edges
    svg.querySelectorAll("line").forEach(line => {
        line.addEventListener("click", () => {
            const index = parseInt(line.getAttribute("data-index"), 10);
            if(!isNaN(index)){
                l4CurrentEdges.splice(index, 1);
                l4ErasedEdges++;

                const now = performance.now();
                if(l4LastActionTime > 0){
                    l4ActionIntervals.push((now - l4LastActionTime)/1000);
                }
                l4LastActionTime = now;

                renderLevel4Svg(vertices, outerCount);
            }
        });
    });

    // Draw edges
    svg.querySelectorAll("circle").forEach(circle => {
        const idx = parseInt(circle.getAttribute("data-vertex"), 10);

        circle.addEventListener("mousedown", () => {
            l4DragStartIndex = idx;
        });

        circle.addEventListener("mouseup", () => {
            if(l4DragStartIndex !== null && l4DragStartIndex !== idx){
                addL4Edge(l4DragStartIndex, idx, vertices, outerCount);
            }
            l4DragStartIndex = null;
        });
    });
}

function addL4Edge(i, j, vertices, outerCount){

    // Prevent duplicate edges
    if(l4CurrentEdges.some(e =>
        (e.i === i && e.j === j) ||
        (e.i === j && e.j === i)
    )) return;

    // Decide whether this belongs to outer or inner polygon
    const isOuter = (i < outerCount && j < outerCount);

    l4CurrentEdges.push({i, j, isOuter});

    const now = performance.now();
    if(l4LastActionTime > 0){
        l4ActionIntervals.push((now - l4LastActionTime) / 1000);
    }
    l4LastActionTime = now;

    renderLevel4Svg(vertices, outerCount);
}

function useHint4(){

    const now = Date.now();
    const hintInfo = document.getElementById("hintInfo4");

    const shapeIndex = l4CurrentShapeIndices[0];
    const shape = level4Shapes[shapeIndex];

    const outerVertices = shape.outer;
    const innerVertices = shape.inner;

    const nOuter = outerVertices.length;
    const nInner = innerVertices.length;

    if(l4HintsUsed >= 3){
        hintInfo.textContent = "Maximum hints used.";
        return;
    }

    if(l4LastHintTime && now - l4LastHintTime < 15000){
        const remain = Math.ceil((15000 - (now - l4LastHintTime)) / 1000);
        hintInfo.textContent = `Next hint in ${remain}s`;
        return;
    }

    // Build list of true edges (outer + inner)
    const trueEdges = [];

    for(let k = 0; k < nOuter; k++){
        const a = k, b = (k+1) % nOuter;
        const ii = Math.min(a,b), jj = Math.max(a,b);
        trueEdges.push({i: ii, j: jj, isOuter: true});
    }

    for(let k = 0; k < nInner; k++){
        const a = nOuter + k;
        const b = nOuter + ((k+1) % nInner);
        const ii = Math.min(a,b), jj = Math.max(a,b);
        trueEdges.push({i: ii, j: jj, isOuter: false});
    }

    // Find an unrevealed edge
    let chosen = null;

    for(const e of trueEdges){
        const exists = l4CurrentEdges.some(x => {
            const xi = Math.min(x.i,x.j), xj = Math.max(x.i,x.j);
            const ei = Math.min(e.i,e.j), ej = Math.max(e.i,e.j);
            return (xi === ei && xj === ej);
        });

        if(!exists){
            chosen = e;
            break;
        }
    }

    if(!chosen){
        hintInfo.textContent = "All edges already revealed.";
        return;
    }

    l4HintsUsed++;
    l4LastHintTime = now;

    const totalVertices = [...outerVertices, ...innerVertices];
    addL4Edge(chosen.i, chosen.j, totalVertices, nOuter);

    hintInfo.textContent = `Hints used: ${l4HintsUsed}/3`;
}

function submitLevel4(){

    const shapeIndex = l4CurrentShapeIndices[0];
    const shape = level4Shapes[shapeIndex];

    const outerVertices = shape.outer;
    const innerVertices = shape.inner;

    const nOuter = outerVertices.length;
    const nInner = innerVertices.length;

    const end = performance.now();
    const timeTaken = ((end - l4RoundStartTime)/1000).toFixed(2);

    // True edge sets
    const trueOuterEdges = [];
    for(let k=0;k<nOuter;k++){
        const a=k, b=(k+1)%nOuter;
        const ii=Math.min(a,b), jj=Math.max(a,b);
        trueOuterEdges.push(`${ii}-${jj}`);
    }

    const trueInnerEdges = [];
    for(let k=0;k<nInner;k++){
        const a=nOuter+k, b=nOuter+((k+1)%nInner);
        const ii=Math.min(a,b), jj=Math.max(a,b);
        trueInnerEdges.push(`${ii}-${jj}`);
    }

    const trueOuterSet = new Set(trueOuterEdges);
    const trueInnerSet = new Set(trueInnerEdges);

    const userOuterEdges = l4CurrentEdges
        .filter(e => e.isOuter)
        .map(e => {
            const ii = Math.min(e.i,e.j), jj = Math.max(e.i,e.j);
            return `${ii}-${jj}`;
        });

    const userInnerEdges = l4CurrentEdges
        .filter(e => !e.isOuter)
        .map(e => {
            const ii = Math.min(e.i,e.j), jj = Math.max(e.i,e.j);
            return `${ii}-${jj}`;
        });

    const userOuterSet = new Set(userOuterEdges);
    const userInnerSet = new Set(userInnerEdges);

    // Count mistakes
    let outerMissing = 0, outerWrong = 0;
    for(const t of trueOuterEdges) if(!userOuterSet.has(t)) outerMissing++;
    for(const u of userOuterEdges) if(!trueOuterSet.has(u)) outerWrong++;

    let innerMissing = 0, innerWrong = 0;
    for(const t of trueInnerEdges) if(!userInnerSet.has(t)) innerMissing++;
    for(const u of userInnerEdges) if(!trueInnerSet.has(u)) innerWrong++;

    const totalMissing = outerMissing + innerMissing;
    const totalWrong = outerWrong + innerWrong;

    // Intersection checking
    const totalVertices = [...outerVertices, ...innerVertices];
    let intersect = false;

    for(let i=0;i<l4CurrentEdges.length;i++){
        for(let j=i+1;j<l4CurrentEdges.length;j++){
            if(edgesIntersect(l4CurrentEdges[i], l4CurrentEdges[j], totalVertices)){
                intersect = true;
                break;
            }
        }
        if(intersect) break;
    }

    const now = performance.now();
    if(l4LastActionTime > 0){
        l4ActionIntervals.push((now - l4LastActionTime)/1000);
    }

    const avgInterval =
        l4ActionIntervals.length > 0
        ? (l4ActionIntervals.reduce((a,b)=>a+b) / l4ActionIntervals.length).toFixed(2)
        : 0;

    const timeBeforeSubmit =
        l4ActionIntervals.length > 0
        ? l4ActionIntervals[l4ActionIntervals.length - 1].toFixed(2)
        : 0;

    const correct = (totalMissing === 0 && totalWrong === 0 && !intersect);

    l4Results.push({
        correct,
        shapeName: shape.name,
        time: timeTaken,
        hints: l4HintsUsed,
        outerMissing,
        outerWrong,
        innerMissing,
        innerWrong,
        totalMissing,
        totalWrong,
        intersect,
        erased: l4ErasedEdges,
        avgActionInterval: avgInterval,
        timeBeforeSubmit
    });

    if(l4RoundIndex === 1){
        endLevel4();
    } else {
        l4RoundIndex++;
        startLevel4Round();
    }
}

function endLevel4(){

    let html = "";

    l4Results.forEach((r,i) => {
        html += `
            <h3 style="text-align:center;">Round ${i+1} (${r.shapeName})</h3>
            <table class="results-table">
                <tr><td>Result</td><td>${r.correct ? "Correct" : "Wrong"}</td></tr>
                <tr><td>Time Taken</td><td>${r.time} sec</td></tr>
                <tr><td>Hints Used</td><td>${r.hints}</td></tr>
                <tr><td>Outer Edges Missing</td><td>${r.outerMissing}</td></tr>
                <tr><td>Outer Edges Wrong</td><td>${r.outerWrong}</td></tr>
                <tr><td>Inner Edges Missing</td><td>${r.innerMissing}</td></tr>
                <tr><td>Inner Edges Wrong</td><td>${r.innerWrong}</td></tr>
                <tr><td>Total Missing</td><td>${r.totalMissing}</td></tr>
                <tr><td>Total Wrong</td><td>${r.totalWrong}</td></tr>
                <tr><td>Any Intersections</td><td>${r.intersect ? "Yes" : "No"}</td></tr>
                <tr><td>Edges Erased</td><td>${r.erased}</td></tr>
                <tr><td>Avg Time Between Actions</td><td>${r.avgActionInterval} sec</td></tr>
                <tr><td>Time Before Submit</td><td>${r.timeBeforeSubmit} sec</td></tr>
            </table>
        `;
    });

  document.getElementById("summary4").innerHTML = html;
  if(assessmentMode === 'patient'){
    showScreen('level5Intro');
  } else {
    showScreen("results4");
  }
}/* ============ LEVEL 5 FLOW ============ */
function startLevel5(){
  l5RoundIndex = 0;
  l5Results = [];
  showScreen("level5");
  startLevel5Round();
}

function startLevel5Round(){
  const pointSet = level5PointSets[l5RoundIndex];
  const points = pointSet.points;

  l5CurrentEdges = [];
  l5DragStartIndex = null;
  l5LastActionTime = 0;
  l5ActionIntervals = [];
  l5ErasedEdges = 0;

  document.getElementById("level5Text").textContent = `Round ${l5RoundIndex + 1}: Create two separate triangles that do not touch.`;
  document.getElementById("level5Info").textContent = "Draw your first triangle (black), then your second triangle (blue).";

  l5RoundStartTime = performance.now();
  renderLevel5Svg(points);
}

function renderLevel5Svg(points){
  const container = document.getElementById("level5Container");

  const triangle1Vertices = new Set();
  const triangle2Vertices = new Set();
  
  l5CurrentEdges.forEach(e=>{
    if(e.triangleNum === 1){
      triangle1Vertices.add(e.i);
      triangle1Vertices.add(e.j);
    } else if(e.triangleNum === 2){
      triangle2Vertices.add(e.i);
      triangle2Vertices.add(e.j);
    }
  });

  const linesHtml = l5CurrentEdges.map((e,idx)=>{
    const a=points[e.i], b=points[e.j];
    const color = e.triangleNum === 1 ? "black" : "blue";
    return `<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}"
                  stroke="${color}" stroke-width="2"
                  data-index="${idx}" />`;
  }).join("");

  const pointsHtml = points.map((v,idx)=>{
    let color = "#666";
    if(triangle1Vertices.has(idx)) color = "black";
    if(triangle2Vertices.has(idx)) color = "blue";
    if(triangle1Vertices.has(idx) && triangle2Vertices.has(idx)) color = "red";
    
    return `<circle cx="${v.x}" cy="${v.y}" r="3.5" fill="${color}"
            data-vertex="${idx}"
            style="cursor:pointer; pointer-events:auto;" />`;
  }).join("");

  container.innerHTML = `
    <svg id="level5Svg" viewBox="0 0 100 100" width="500" height="500">
      ${linesHtml}
      ${pointsHtml}
    </svg>
  `;

  const svg = document.getElementById("level5Svg");

  svg.querySelectorAll("line").forEach(line=>{
    line.addEventListener("click", ()=>{
      const index = parseInt(line.getAttribute("data-index"),10);
      if(!isNaN(index)){
        l5CurrentEdges.splice(index,1);
        l5ErasedEdges++;
        
        const now = performance.now();
        if(l5LastActionTime > 0){
          l5ActionIntervals.push((now - l5LastActionTime)/1000);
        }
        l5LastActionTime = now;
        
        renderLevel5Svg(points);
      }
    });
  });

  svg.querySelectorAll("circle").forEach(circle=>{
    const idx = parseInt(circle.getAttribute("data-vertex"),10);

    circle.addEventListener("mousedown", ()=>{
      l5DragStartIndex = idx;
    });

    circle.addEventListener("mouseup", ()=>{
      if(l5DragStartIndex !== null && l5DragStartIndex !== idx){
        addL5Edge(l5DragStartIndex, idx, points);
      }
      l5DragStartIndex = null;
    });
  });
}

function addL5Edge(i,j,points){
  if(l5CurrentEdges.some(e => (e.i===i && e.j===j) || (e.i===j && e.j===i))) return;
  
  const triangle1Vertices = new Set();
  const triangle2Vertices = new Set();
  
  l5CurrentEdges.forEach(e=>{
    if(e.triangleNum === 1){
      triangle1Vertices.add(e.i);
      triangle1Vertices.add(e.j);
    } else if(e.triangleNum === 2){
      triangle2Vertices.add(e.i);
      triangle2Vertices.add(e.j);
    }
  });

  let triangleNum = 0;
  
  if(triangle1Vertices.has(i) || triangle1Vertices.has(j)){
    triangleNum = 1;
  }
  else if(triangle2Vertices.has(i) || triangle2Vertices.has(j)){
    triangleNum = 2;
  }
  else {
    if(triangle1Vertices.size < 3){
      triangleNum = 1;
    } else {
      triangleNum = 2;
    }
  }
  
  l5CurrentEdges.push({i, j, triangleNum});
  
  const now = performance.now();
  if(l5LastActionTime > 0){
    l5ActionIntervals.push((now - l5LastActionTime)/1000);
  }
  l5LastActionTime = now;
  
  renderLevel5Svg(points);
}

function submitLevel5(){
  const pointSet = level5PointSets[l5RoundIndex];
  const points = pointSet.points;

  const end = performance.now();
  const timeTaken = ((end - l5RoundStartTime)/1000).toFixed(2);

  const triangle1Edges = l5CurrentEdges.filter(e => e.triangleNum === 1);
  const triangle2Edges = l5CurrentEdges.filter(e => e.triangleNum === 2);

  const triangle1Vertices = new Set();
  triangle1Edges.forEach(e => {
    triangle1Vertices.add(e.i);
    triangle1Vertices.add(e.j);
  });

  const triangle2Vertices = new Set();
  triangle2Edges.forEach(e => {
    triangle2Vertices.add(e.i);
    triangle2Vertices.add(e.j);
  });

  const hasTriangle1 = triangle1Edges.length === 3 && triangle1Vertices.size === 3;
  const hasTriangle2 = triangle2Edges.length === 3 && triangle2Vertices.size === 3;
  const hasTwoTriangles = hasTriangle1 && hasTriangle2;

  const sharedVertices = [...triangle1Vertices].filter(v => triangle2Vertices.has(v));
  const hasSharedVertices = sharedVertices.length > 0;

  const sharedEdges = triangle1Edges.filter(e1 => {
    const i1 = Math.min(e1.i, e1.j), j1 = Math.max(e1.i, e1.j);
    return triangle2Edges.some(e2 => {
      const i2 = Math.min(e2.i, e2.j), j2 = Math.max(e2.i, e2.j);
      return i1 === i2 && j1 === j2;
    });
  });
  const hasSharedEdges = sharedEdges.length > 0;

  let hasIntersection = false;
  for(const e1 of triangle1Edges){
    for(const e2 of triangle2Edges){
      if(edgesIntersect(e1, e2, points)){
        hasIntersection = true;
        break;
      }
    }
    if(hasIntersection) break;
  }

  const t1Valid = hasTriangle1 && isValidTriangle(triangle1Edges, triangle1Vertices);
  const t2Valid = hasTriangle2 && isValidTriangle(triangle2Edges, triangle2Vertices);

  const trianglesSeparate = !hasSharedVertices && !hasSharedEdges && !hasIntersection;
  const correct = hasTwoTriangles && t1Valid && t2Valid && trianglesSeparate;

  const now = performance.now();
  if(l5LastActionTime > 0){
    l5ActionIntervals.push((now - l5LastActionTime)/1000);
  }
  
  const avgInterval = l5ActionIntervals.length > 0
    ? (l5ActionIntervals.reduce((a,b)=>a+b,0) / l5ActionIntervals.length).toFixed(2)
    : 0;
  const timeBeforeSubmit = l5ActionIntervals.length > 0
    ? l5ActionIntervals[l5ActionIntervals.length - 1].toFixed(2)
    : 0;

  l5Results.push({
    correct,
    time: timeTaken,
    hasTwoTriangles,
    triangle1Valid: t1Valid,
    triangle2Valid: t2Valid,
    hasSharedVertices,
    sharedVertexCount: sharedVertices.length,
    hasSharedEdges,
    sharedEdgeCount: sharedEdges.length,
    hasIntersection,
    trianglesSeparate,
    erased: l5ErasedEdges,
    avgActionInterval: avgInterval,
    timeBeforeSubmit: timeBeforeSubmit
  });

  if(l5RoundIndex === level5PointSets.length - 1){
    endLevel5();
  } else {
    l5RoundIndex++;
    startLevel5Round();
  }
}

function isValidTriangle(edges, vertices){
  if(edges.length !== 3 || vertices.size !== 3) return false;
  
  const degree = new Map();
  edges.forEach(e => {
    degree.set(e.i, (degree.get(e.i) || 0) + 1);
    degree.set(e.j, (degree.get(e.j) || 0) + 1);
  });
  
  return [...degree.values()].every(d => d === 2);
}

function endLevel5(){
  let html = "";
  l5Results.forEach((r,i)=>{
    html += `
      <h3 style="text-align:center;">Round ${i+1}</h3>
      <table class="results-table">
        <tr><td>Result</td><td>${r.correct ? "Correct" : "Wrong"}</td></tr>
        <tr><td>Time Taken</td><td>${r.time} sec</td></tr>
        <tr><td>Has Two Triangles</td><td>${r.hasTwoTriangles ? "Yes" : "No"}</td></tr>
        <tr><td>Triangle 1 Valid</td><td>${r.triangle1Valid ? "Yes" : "No"}</td></tr>
        <tr><td>Triangle 2 Valid</td><td>${r.triangle2Valid ? "Yes" : "No"}</td></tr>
        <tr><td>Triangles Separate</td><td>${r.trianglesSeparate ? "Yes" : "No"}</td></tr>
        <tr><td>Shared Vertices</td><td>${r.sharedVertexCount}</td></tr>
        <tr><td>Shared Edges</td><td>${r.sharedEdgeCount}</td></tr>
        <tr><td>Edges Intersect</td><td>${r.hasIntersection ? "Yes" : "No"}</td></tr>
        <tr><td>Edges Erased</td><td>${r.erased}</td></tr>
        <tr><td>Avg Time Between Actions</td><td>${r.avgActionInterval} sec</td></tr>
        <tr><td>Time Before Submit</td><td>${r.timeBeforeSubmit} sec</td></tr>
      </table>
    `;
  });

  document.getElementById("summary5").innerHTML = html;
  if(assessmentMode === 'patient'){
    // Auto-download CSV and show completion message
    downloadCSV();
    alert('Assessment complete! Results have been downloaded.');
    showScreen('modeSelection');
  } else {
    showScreen("results5");
  }
}

/* ============ CSV EXPORT ============ */
function downloadCSV(){
  let csv = [];
  
  // Level 1 - Flip
  if(level1Results.flip){
    csv.push([
      'Level 1',
      'Flip',
      level1Results.flip.correct ? 'Correct' : 'Wrong',
      level1Results.flip.time,
      level1Results.flip.avgActionInterval,
      level1Results.flip.timeBeforeSubmit,
      '', '', '', '', '', '', '', '', ''
    ]);
  }
  
  // Level 1 - Rotation
  if(level1Results.rotation){
    csv.push([
      'Level 1',
      'Rotation',
      level1Results.rotation.correct ? 'Correct' : 'Wrong',
      level1Results.rotation.time,
      level1Results.rotation.avgActionInterval,
      level1Results.rotation.timeBeforeSubmit,
      '', '', '', '', '', '', '', '', ''
    ]);
  }
  
  // Level 2
  l2Results.forEach((r, i) => {
    csv.push([
      'Level 2',
      `Round ${i+1}`,
      r.correct ? 'Correct' : 'Wrong',
      r.time,
      r.avgActionInterval,
      r.timeBeforeSubmit,
      r.hints,
      r.missing,
      r.wrong,
      r.intersect ? 'Yes' : 'No',
      r.closed ? 'Yes' : 'No',
      r.erased,
      r.followOrder ? 'Yes' : 'No',
      '', ''
    ]);
  });
  
  // Level 3
  l3Results.forEach((r, i) => {
    csv.push([
      'Level 3',
      `Round ${i+1}`,
      r.correct ? 'Correct' : 'Wrong',
      r.time,
      r.avgActionInterval,
      r.timeBeforeSubmit,
      r.hints,
      r.missing,
      r.wrong,
      r.intersect ? 'Yes' : 'No',
      r.closed ? 'Yes' : 'No',
      r.erased,
      '', '', ''
    ]);
  });
  
  // Level 4
  l4Results.forEach((r, i) => {
    csv.push([
      'Level 4',
      `${r.shapeName} (Round ${i+1})`,
      r.correct ? 'Correct' : 'Wrong',
      r.time,
      r.avgActionInterval,
      r.timeBeforeSubmit,
      r.hints,
      `Outer: ${r.outerMissing}, Inner: ${r.innerMissing}, Total: ${r.totalMissing}`,
      `Outer: ${r.outerWrong}, Inner: ${r.innerWrong}, Total: ${r.totalWrong}`,
      r.intersect ? 'Yes' : 'No',
      '', // closed shape not tracked in L4
      r.erased,
      '', '', ''
    ]);
  });
  
  // Level 5
  l5Results.forEach((r, i) => {
    csv.push([
      'Level 5',
      `Round ${i+1}`,
      r.correct ? 'Correct' : 'Wrong',
      r.time,
      r.avgActionInterval,
      r.timeBeforeSubmit,
      '', // no hints in L5
      '', // edges missing tracked differently
      '', // edges wrong tracked differently
      r.hasIntersection ? 'Yes' : 'No',
      '', // closed tracked per triangle
      r.erased,
      '',
      `T1: ${r.triangle1Valid ? 'Yes' : 'No'}, T2: ${r.triangle2Valid ? 'Yes' : 'No'}`,
      `Shared vertices: ${r.sharedVertexCount}, Shared edges: ${r.sharedEdgeCount}, Separate: ${r.trianglesSeparate ? 'Yes' : 'No'}`
    ]);
  });
  
  // Add header
  csv.unshift([
    'Level',
    'Round/Type',
    'Result',
    'Time (sec)',
    'Avg Action Interval (sec)',
    'Time Before Submit (sec)',
    'Hints Used',
    'Edges Missing',
    'Edges Wrong',
    'Intersections',
    'Closed Shape',
    'Edges Erased',
    'Followed Order',
    'Triangle Validity',
    'Additional Info'
  ]);
  
  // Convert to CSV string
  const csvContent = csv.map(row => 
    row.map(cell => {
      // Escape quotes and wrap in quotes if contains comma or quote
      const str = String(cell);
      if(str.includes(',') || str.includes('"') || str.includes('\n')){
        return '"' + str.replace(/"/g, '""') + '"';
      }
      return str;
    }).join(',')
  ).join('\n');
  
  // Download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  
  link.setAttribute('href', url);
  link.setAttribute('download', `polymind_results_${timestamp}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
</script>

</body>
</html>
